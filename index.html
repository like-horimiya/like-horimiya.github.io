<!DOCTYPE html>
<html>
 
<head>
    <meta charset="UTF-8">
    <link href="https://fonts.googleapis.com/css?family=M+PLUS+1p" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=M+PLUS+Rounded+1c" rel="stylesheet">

    <link href="https://fonts.googleapis.com/css?family=Hachi+Maru+Pop" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Yusei+Magic" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Reggae+One" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Noto+Sans+JP" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Sawarabi+Gothic" rel="stylesheet">
    <link href="https://fonts.googleapis.com/earlyaccess/nicomoji.css" rel="stylesheet">

    <link href="./font.css" rel="stylesheet">

    <link rel="icon" href="./img/favicon2/favicon.ico" />
    <script src="js/bouyomichan_client.js"></script>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-5RNP0LDER8"></script>
    <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-5RNP0LDER8');
    </script>
    <!-- END: Google tag (gtag.js) -->

    <title>jimakuChan: 音声認識字幕ちゃん v2025.9.2 18:51 [CONFIG]</title>

    <style type="text/css">
        /* グローバルなbox-sizingリセット */
        *,
        *::before,
        *::after {
            box-sizing: border-box;
        }

        button, input, select, textarea {
            /* font-family : inherit; */
            /* font-family: 'メイリオ', Meiryo,sans-serif; */
            /* font-size   : 300%; */
            /* color  : black; */
            font-weight : 0;
            /*text-align  : center;       /* left, center, right */
            vertical-align : top;    /* top, middle, bottom */
            -webkit-text-stroke-color: rgb(21, 0, 141);
            -webkit-text-stroke-width: 0px;
        }

        html {
            height: 100%;
            width: 100%;
        }

        body {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            overflow-x: auto;
            font-family: 'M PLUS Rounded 1c', sans-serif;
            /* font-family:'07NikumaruFont'; */
        }
        table {
            width: 100%;
            /* table-layout: fixed; */
        }
        table.btm_table {
            position:absolute;
            /* bottom:0; */
        }

        table td {
            /*word-break: break-all;*/
            overflow-wrap : break-word;
        }
    </style>

    <style>
        /* prepare the selectors to add a stroke to */

        .stroke-single-imb{
            /* position: absolute; */
            left: 0;
            right: 0;
            margin: 0;
            /* -webkit-text-stroke: 0px #0000FF;  */
        }

        .stroke-single-bg{
            position: absolute;
            left: 0;
            right: 0;
            margin: auto;
            /* -webkit-text-stroke: 3px #FF0000;  */
        }
        /* add a single stroke */
        .stroke-single-fg{
            position: absolute;
            left: 0;
            right: 0;
            margin: auto;
            /* -webkit-text-stroke: 0px #FFFFFF; */
        }
    </style>

</head>
 

<body>

<!-- # 注意事項 ######################### -->
<!-- <iframe src="" name="sample" width="100%" height="30%" id="asr_frame" onclick="toggleIframeHeight()"></iframe> -->
<iframe src="" name="sample" width="100%" height="30%" id="asr_frame" onclick="toggleIframeHeight()" style="border: none;"></iframe>

　上の画面をクリックすると設定画面が閉じ，もう一度押すと再度開きます．<BR>
<HR>

<!-- # プリセット機能とAPIキー ################## -->
<div style="display: flex; gap: 10px; margin-bottom: 5px;">
    <!-- 左側：設定プリセット -->
    <div style="width: 280px; background-color: #ffe0e6; padding: 8px 10px; border-radius: 5px;">
        <div style="font-size: 14px; margin-bottom: 4px;">設定プリセット：</div>
        <select id="presetSelect" onchange="loadPreset()" style="width: 100%; margin-bottom: 4px;">
            <option value="default">📋 選択してください</option>
            <option value="gaming">🎮 ゲーム配信用</option>
            <option value="meeting">💼 会議・打ち合わせ用</option>
            <option value="language_learning">📚 語学学習用</option>
            <option value="accessibility">♿ アクセシビリティ重視</option>
            <option value="cute_streaming">🌸 かわいい配信用</option>
            <option value="dark_theme">🌙 ダークテーマ</option>
            <option value="rainbow">🌈 レインボー</option>
            <option value="custom1">🔧 カスタム１</option>
            <option value="custom2">🔧 カスタム２</option>
            <option value="custom3">🔧 カスタム３</option>
        </select>
        <small style="color: #666; font-size: 12px;">※ 選択すると設定が自動保存されます ✨</small>
    </div>
    
    <!-- 右側：APIキー関連 -->
    <div style="flex: 1; background-color: #e0e8ff; padding: 8px 10px; border-radius: 5px;">
        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 3px;">
            <span style="font-size: 14px;">翻訳用 Google API-KEY：</span>
            <input type="text" name="gas_key" id="gas_key" size="30" oninput="updateOptionValues();" style="height: 22px;" />
            <a target="_blank" href="http://www.sayonari.com/trans_asr/index_asr.html" style="font-size: 11px;">[作成方法]</a>
        </div>
        <div style="font-size: 13px;">
            <span id="apiModeDisplay">
                翻訳回数：<span id="displayTransCount">0</span><span style="color: gray; font-size: 11px;">（無料上限5,000回）</span>
            </span>
            　翻訳：<span id="translationStatus" style="font-weight: bold; color: #666;">待機中</span>
        </div>
        <div id="chromeTranslationMode" style="display: none; margin-top: 5px; padding: 10px; background: linear-gradient(135deg, #84fab0 0%, #8fd3f4 100%); border-radius: 5px;">
            <div style="margin-bottom: 8px;">
                <div style="margin-bottom: 8px;">
                    <span id="chromeTranslationStatus" style="font-size: 14px; font-weight: bold; color: #1a5e3a;">
                        🚀 高速翻訳対応Chromeで起動！
                    </span>
                </div>
                
                <!-- 翻訳方法選択スイッチ -->
                <div style="margin-bottom: 8px;">
                    <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap;">
                        <span style="font-size: 14px; color: #1a5e3a; font-weight: bold;">翻訳方法：</span>
                        <label style="display: flex; align-items: center; gap: 4px; cursor: pointer; font-size: 14px; color: #1a5e3a;">
                            <input type="radio" name="translationMethod" value="chrome" id="translationMethodChrome" 
                                   onchange="switchTranslationMethod()" checked>
                            Chrome内蔵(高速)
                        </label>
                        <label style="display: flex; align-items: center; gap: 4px; cursor: pointer; font-size: 14px; color: #1a5e3a;">
                            <input type="radio" name="translationMethod" value="gas" id="translationMethodGas" 
                                   onchange="switchTranslationMethod()">
                            GAS API
                        </label>
                    </div>
                </div>
                
                <!-- Chrome内蔵翻訳選択時の注意書き -->
                <div id="chromeTranslationNotice" style="font-size: 12px; color: #666; line-height: 1.3;">
                    <span id="chromeTranslationNoticeText">※Chrome内蔵(高速)は，1時間程でエラーで止まります（原因調査中）</span>
                </div>
            </div>
            <div id="modelDownloadArea" style="display: none; margin-top: 8px; padding: 10px; background: linear-gradient(135deg, #fff3cd 0%, #ffe8a1 100%); border-radius: 5px; border: 2px solid #ffc107;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <button id="preloadModelBtn" onclick="preloadTranslationModel()" style="padding: 8px 16px; background: #ff6b6b; color: white; border: none; border-radius: 5px; font-weight: bold; cursor: pointer; font-size: 14px; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">
                        📥 モデルをダウンロード
                    </button>
                    <span id="modelQueueStatus" style="padding: 4px 8px; background: rgba(255, 255, 255, 0.8); border-radius: 4px; font-size: 12px; color: #666; font-weight: bold; display: none;">
                        📦 残り0個
                    </span>
                    <span id="modelStatusText" style="font-size: 13px; color: #333; font-weight: bold;"></span>
                </div>
            </div>
            <div id="downloadStatusArea" style="display: none; margin-top: 8px; padding: 8px; background: rgba(255, 255, 255, 0.9); border-radius: 4px;">
                <span id="downloadStatusText" style="font-size: 13px; color: #333;"></span>
            </div>
        </div>
    </div>
</div>
<HR>

<!-- # テキスト設定 (テーブルレイアウト) ######################### -->
<table style="border-collapse: separate; border-spacing: 0px;">
<tr>
    <td></td>
    <td style="text-align: center; width: 50px;">文字色</td>
    <td style="text-align: center; width: 50px;">フチ色</td>
    <td style="text-align: center; width: 120px;">サイズ</td>
    <td style="text-align: center; width: 120px;">ウェイト</td>
    <td style="text-align: center; width: 120px;">縁取り</td>
</tr>
<tr>
    <td style="width: 60px;">認識　：</td>
    <td style="text-align: center;">
        <input id="color1" type="color" value="#ffffff" oninput="changeTextColor('fg',this.value,1); updateOptionValues(only_url=true)" />
    </td>
    <td style="text-align: center;">
        <input id="st_color1" type="color" value="#000000" oninput="changeTextColor('bg',this.value,1); updateOptionValues(only_url=true)" />
    </td>
    <td style="text-align: center;">
        <input id="size1" type="range" value="25" min="0" max="40" step="0.1" oninput="document.getElementById('asr_frame').contentWindow.document.getElementById('speech_text').style.fontSize = this.value + 'pt'; document.getElementById('text_size_view1').innerHTML=this.value; updateOptionValues(only_url=true)" />
        <span id="text_size_view1">25</span>px
    </td>
    <td style="text-align: center;">
        <input id="weight1" type="range" value="900" min="100" max="900" step="100" oninput="document.getElementById('asr_frame').contentWindow.document.getElementById('speech_text').style.fontWeight = this.value; document.getElementById('text_weight_view1').innerHTML=this.value; updateOptionValues(only_url=true)" />
        <span id="text_weight_view1">900</span>
    </td>
    <td style="text-align: center;">
        <input id="st_width1" type="range" value="6" min="0" max="20" step="0.1" oninput="setTextBorder(this.value,1); document.getElementById('text_st_size_view1').innerHTML=this.value; updateOptionValues(only_url=true)" />
        <span id="text_st_size_view1">6</span>pt
    </td>
</tr>
<tr>
    <td>翻訳１：</td>
    <td style="text-align: center;">
        <input id="color2" type="color" value="#ffffff" oninput="changeTextColor('fg',this.value,2); updateOptionValues(only_url=true)" />
    </td>
    <td style="text-align: center;">
        <input id="st_color2" type="color" value="#000000" oninput="changeTextColor('bg',this.value,2); updateOptionValues(only_url=true)" />
    </td>
    <td style="text-align: center;">
        <input id="size2" type="range" value="25" min="0" max="40" step="0.1" oninput="document.getElementById('asr_frame').contentWindow.document.getElementById('trans_text').style.fontSize = this.value + 'pt'; document.getElementById('text_size_view2').innerHTML=this.value; updateOptionValues(only_url=true)" />
        <span id="text_size_view2">25</span>px
    </td>
    <td style="text-align: center;">
        <input id="weight2" type="range" value="900" min="100" max="900" step="100" oninput="document.getElementById('asr_frame').contentWindow.document.getElementById('trans_text').style.fontWeight = this.value; document.getElementById('text_weight_view2').innerHTML=this.value; updateOptionValues(only_url=true)" />
        <span id="text_weight_view2">900</span>
    </td>
    <td style="text-align: center;">
        <input id="st_width2" type="range" value="6" min="0" max="20" step="0.1" oninput="setTextBorder(this.value,2); document.getElementById('text_st_size_view2').innerHTML=this.value; updateOptionValues(only_url=true)" />
        <span id="text_st_size_view2">6</span>pt
    </td>
</tr>
<tr>
    <td>翻訳２：</td>
    <td style="text-align: center;">
        <input id="color3" type="color" value="#ffffff" oninput="changeTextColor('fg',this.value,3); updateOptionValues(only_url=true)" />
    </td>
    <td style="text-align: center;">
        <input id="st_color3" type="color" value="#000000" oninput="changeTextColor('bg',this.value,3); updateOptionValues(only_url=true)" />
    </td>
    <td style="text-align: center;">
        <input id="size3" type="range" value="25" min="0" max="40" step="0.1" oninput="document.getElementById('asr_frame').contentWindow.document.getElementById('trans_text2').style.fontSize = this.value + 'pt'; document.getElementById('text_size_view3').innerHTML=this.value; updateOptionValues(only_url=true)" />
        <span id="text_size_view3">25</span>px
    </td>
    <td style="text-align: center;">
        <input id="weight3" type="range" value="900" min="100" max="900" step="100" oninput="document.getElementById('asr_frame').contentWindow.document.getElementById('trans_text2').style.fontWeight = this.value; document.getElementById('text_weight_view3').innerHTML=this.value; updateOptionValues(only_url=true)" />
        <span id="text_weight_view3">900</span>
    </td>
    <td style="text-align: center;">
        <input id="st_width3" type="range" value="6" min="0" max="20" step="0.1" oninput="setTextBorder(this.value,3); document.getElementById('text_st_size_view3').innerHTML=this.value; updateOptionValues(only_url=true)" />
        <span id="text_st_size_view3">6</span>pt
    </td>
</tr>
<tr>
    <td>翻訳３：</td>
    <td style="text-align: center;">
        <input id="color4" type="color" value="#ffffff" oninput="changeTextColor('fg',this.value,4); updateOptionValues(only_url=true)" />
    </td>
    <td style="text-align: center;">
        <input id="st_color4" type="color" value="#000000" oninput="changeTextColor('bg',this.value,4); updateOptionValues(only_url=true)" />
    </td>
    <td style="text-align: center;">
        <input id="size4" type="range" value="25" min="0" max="40" step="0.1" oninput="document.getElementById('asr_frame').contentWindow.document.getElementById('trans_text3').style.fontSize = this.value + 'pt'; document.getElementById('text_size_view4').innerHTML=this.value; updateOptionValues(only_url=true)" />
        <span id="text_size_view4">25</span>px
    </td>
    <td style="text-align: center;">
        <input id="weight4" type="range" value="900" min="100" max="900" step="100" oninput="document.getElementById('asr_frame').contentWindow.document.getElementById('trans_text3').style.fontWeight = this.value; document.getElementById('text_weight_view4').innerHTML=this.value; updateOptionValues(only_url=true)" />
        <span id="text_weight_view4">900</span>
    </td>
    <td style="text-align: center;">
        <input id="st_width4" type="range" value="6" min="0" max="20" step="0.1" oninput="setTextBorder(this.value,4); document.getElementById('text_st_size_view4').innerHTML=this.value; updateOptionValues(only_url=true)" />
        <span id="text_st_size_view4">6</span>pt
    </td>
</tr>
</table>

背景色：<input id="bgcolor" type="color" value="transparent" oninput="updateOptionValues(only_url=true)" />

<HR>

<!-- # 言語選択設定 ######################### -->
音声認識言語　：
<select id="recog" onchange="updateOptionValues(only_url=false); checkAllTranslationModels();">
    <option value="ja" selected>日本語</option>
    <option value="en-US">英語</option>
    <option value="ko">韓国語</option>
    <option value="zh-CN">中国語</option>
    <option value="zh-TW">台湾語</option>
    <option value="zh-HK">香港語</option>
    <option value="fr-FR">フランス語</option>
    <option value="it-IT">イタリア語</option>
    <option value="de-DE">ドイツ語</option>
    <option value="tr-TR">トルコ語</option>
    <option value="sv-SE">スウェーデン語</option>
    <option value="pl-PL">ポーランド語</option>
    <option value="uk-UA">ウクライナ語</option>
    <option value="ru-RU">ロシア語</option>
    <option value="es-ES">スペイン語</option>
    <option value="pt-PT">ポルトガル語</option>
    <option value="nl-NL">オランダ語</option>
    <option value="id-ID">インドネシア語</option>
    <option value="vi-VN">ベトナム語</option>
    <option value="th-TH">タイ語</option>
    <option value="ar-SA">アラビア語</option>
    <option value="el-GR">ギリシャ語</option>
</select>　　

フォント　：
<select name="speech_text_font_selector" id="speech_text_font_selector" onchange="applySelectedFont(this, 'speech_text'); selectFont(); updateOptionValues();">
    <option value="direct">[PC内フォント]</option>
    <option value="M PLUS\\ 1p">M PLUS 1p</option>
    <option value="M PLUS Rounded\\ 1c" selected>M PLUS Rounded 1c</option>
    <option value="Mamelon">マメロン</option>
    <option value="YasashisaB">やさしさB</option>
    <option value="HuiFont29">ふい字</option>
    <option value="Hachi Maru Pop">Hachi Maru Pop</option>
    <option value="MkPOP">851マカポップ</option>
    <option value="bananaslipplus">バナナスリップplus</option>
    <option value="katyou">花鳥風月</option>
    <option value="TanukiMagic">たぬき油性マジック</option>
    <option value="hakidame">吐き溜</option>
    <option value="umeboshi">梅干し</option>
    <option value="Jiyucho">じゆうちょう</option>
    <option value="HitmoR">Hitmo</option>
    <option value="nishikiteki">にしき的</option>
    <option value="Yusei Magic">Yusei Magic</option>
    <option value="Nikumaru">にくまる</option>
    <option value="KTEGAKI">kawaii手書き</option>
    <option value="JKGL">JK Gothic L</option>
    <option value="Reggae One">Reggae One</option>
    <option value="OhisamaFont">おひさま</option>
    <option value="nukamiso">ぬかみそ</option>
    <option value="genkai">源界明朝</option>
    <option value="CP">チェックポイント</option>
    <option value="Noto Sans JP">Noto Sans JP</option>
    <option value="Sawarabi Gothic">さわらびゴシック</option>
    <option value="Nico Moji">ニコモジ</option>
</select>　
PC内フォント：<select id="speech_text_system_font" onchange="applySystemFont(this.value, 'speech_text'); updateOptionValues();"></select>
<input type="text" id="speech_text_direct_font" placeholder="フォント名を入力" style="width: 200px; margin-left: 10px;" disabled oninput="applyDirectFont(this.value, 'speech_text'); updateOptionValues();">
<span id="font_api_status" style="font-size: 12px; margin-left: 10px;"></span><br>

翻訳言語（１）：
<select id="trans" onchange="updateOptionValues(only_url=false, transNum=1); checkTranslationModel(1, event);">
    <option value="none" selected>なし</option>
    <option value="ja">日本語</option>
    <option value="en">英語</option>
    <option value="ko">韓国語</option>
    <option value="zh-CN">中国語</option>
    <option value="zh-TW">台湾語</option>
    <option value="zh-HK">香港語</option>
    <option value="fr">フランス語</option>
    <option value="it">イタリア語</option>
    <option value="de">ドイツ語</option>
    <option value="tr">トルコ語</option>
    <option value="sv">スウェーデン語</option>
    <option value="pl">ポーランド語</option>
    <option value="uk">ウクライナ語</option>
    <option value="ru">ロシア語</option>
    <option value="es">スペイン語</option>
    <option value="pt">ポルトガル語</option>
    <option value="nl">オランダ語</option>
    <option value="id">インドネシア語</option>
    <option value="vi">ベトナム語</option>
    <option value="th">タイ語</option>
    <option value="ar">アラビア語</option>
    <option value="so">ソマリ語</option>
    <option value="el">ギリシャ語</option>
</select>　　

フォント　：
<select name="trans_text_font_selector" id="trans_text_font_selector" onchange="applySelectedFont(this, 'trans_text'); selectFont(); updateOptionValues();">
    <option value="direct">[PC内フォント]</option>
    <option value="M PLUS\\ 1p">M PLUS 1p</option>
    <option value="M PLUS Rounded\\ 1c" selected>M PLUS Rounded 1c</option>
    <option value="Mamelon">マメロン</option>
    <option value="YasashisaB">やさしさB</option>
    <option value="HuiFont29">ふい字</option>
    <option value="Hachi Maru Pop">Hachi Maru Pop</option>
    <option value="MkPOP">851マカポップ</option>
    <option value="bananaslipplus">バナナスリップplus</option>
    <option value="katyou">花鳥風月</option>
    <option value="TanukiMagic">たぬき油性マジック</option>
    <option value="hakidame">吐き溜</option>
    <option value="umeboshi">梅干し</option>
    <option value="Jiyucho">じゆうちょう</option>
    <option value="HitmoR">Hitmo</option>
    <option value="nishikiteki">にしき的</option>
    <option value="Yusei Magic">Yusei Magic</option>
    <option value="Nikumaru">にくまる</option>
    <option value="KTEGAKI">kawaii手書き</option>
    <option value="JKGL">JK Gothic L</option>
    <option value="Reggae One">Reggae One</option>
    <option value="OhisamaFont">おひさま</option>
    <option value="nukamiso">ぬかみそ</option>
    <option value="genkai">源界明朝</option>
    <option value="CP">チェックポイント</option>
    <option value="Noto Sans JP">Noto Sans JP</option>
    <option value="Sawarabi Gothic">さわらびゴシック</option>
    <option value="Nico Moji">ニコモジ</option>
</select>　
PC内フォント：<select id="trans_text_system_font" onchange="applySystemFont(this.value, 'trans_text'); updateOptionValues();"></select>
<input type="text" id="trans_text_direct_font" placeholder="フォント名を入力" style="width: 200px; margin-left: 10px;" disabled oninput="applyDirectFont(this.value, 'trans_text'); updateOptionValues();"><br>

翻訳言語（２）：
<select id="trans2" onchange="updateOptionValues(only_url=false, transNum=2); checkTranslationModel(2, event);">
    <option value="none" selected>なし</option>
    <option value="ja">日本語</option>
    <option value="en">英語</option>
    <option value="ko">韓国語</option>
    <option value="zh-CN">中国語</option>
    <option value="zh-TW">台湾語</option>
    <option value="zh-HK">香港語</option>
    <option value="fr">フランス語</option>
    <option value="it">イタリア語</option>
    <option value="de">ドイツ語</option>
    <option value="tr">トルコ語</option>
    <option value="sv">スウェーデン語</option>
    <option value="pl">ポーランド語</option>
    <option value="uk">ウクライナ語</option>
    <option value="ru">ロシア語</option>
    <option value="es">スペイン語</option>
    <option value="pt">ポルトガル語</option>
    <option value="nl">オランダ語</option>
    <option value="id">インドネシア語</option>
    <option value="vi">ベトナム語</option>
    <option value="th">タイ語</option>
    <option value="ar">アラビア語</option>
    <option value="so">ソマリ語</option>
    <option value="el">ギリシャ語</option>
</select>　　

フォント　：
<select name="trans_text2_font_selector" id="trans_text2_font_selector" onchange="applySelectedFont(this, 'trans_text2'); selectFont(); updateOptionValues();">
    <option value="direct">[PC内フォント]</option>
    <option value="M PLUS\\ 1p">M PLUS 1p</option>
    <option value="M PLUS Rounded\\ 1c" selected>M PLUS Rounded 1c</option>
    <option value="Mamelon">マメロン</option>
    <option value="YasashisaB">やさしさB</option>
    <option value="HuiFont29">ふい字</option>
    <option value="Hachi Maru Pop">Hachi Maru Pop</option>
    <option value="MkPOP">851マカポップ</option>
    <option value="bananaslipplus">バナナスリップplus</option>
    <option value="katyou">花鳥風月</option>
    <option value="TanukiMagic">たぬき油性マジック</option>
    <option value="hakidame">吐き溜</option>
    <option value="umeboshi">梅干し</option>
    <option value="Jiyucho">じゆうちょう</option>
    <option value="HitmoR">Hitmo</option>
    <option value="nishikiteki">にしき的</option>
    <option value="Yusei Magic">Yusei Magic</option>
    <option value="Nikumaru">にくまる</option>
    <option value="KTEGAKI">kawaii手書き</option>
    <option value="JKGL">JK Gothic L</option>
    <option value="Reggae One">Reggae One</option>
    <option value="OhisamaFont">おひさま</option>
    <option value="nukamiso">ぬかみそ</option>
    <option value="genkai">源界明朝</option>
    <option value="CP">チェックポイント</option>
    <option value="Noto Sans JP">Noto Sans JP</option>
    <option value="Sawarabi Gothic">さわらびゴシック</option>
    <option value="Nico Moji">ニコモジ</option>
</select>　
PC内フォント：<select id="trans_text2_system_font" onchange="applySystemFont(this.value, 'trans_text2'); updateOptionValues();"></select>
<input type="text" id="trans_text2_direct_font" placeholder="フォント名を入力" style="width: 200px; margin-left: 10px;" disabled oninput="applyDirectFont(this.value, 'trans_text2'); updateOptionValues();"><br>

翻訳言語（３）：
<select id="trans3" onchange="updateOptionValues(only_url=false, transNum=3); checkTranslationModel(3, event);">
    <option value="none" selected>なし</option>
    <option value="ja">日本語</option>
    <option value="en">英語</option>
    <option value="ko">韓国語</option>
    <option value="zh-CN">中国語</option>
    <option value="zh-TW">台湾語</option>
    <option value="zh-HK">香港語</option>
    <option value="fr">フランス語</option>
    <option value="it">イタリア語</option>
    <option value="de">ドイツ語</option>
    <option value="tr">トルコ語</option>
    <option value="sv">スウェーデン語</option>
    <option value="pl">ポーランド語</option>
    <option value="uk">ウクライナ語</option>
    <option value="ru">ロシア語</option>
    <option value="es">スペイン語</option>
    <option value="pt">ポルトガル語</option>
    <option value="nl">オランダ語</option>
    <option value="id">インドネシア語</option>
    <option value="vi">ベトナム語</option>
    <option value="th">タイ語</option>
    <option value="ar">アラビア語</option>
    <option value="so">ソマリ語</option>
    <option value="el">ギリシャ語</option>
</select>　　

フォント　：
<select name="trans_text3_font_selector" id="trans_text3_font_selector" onchange="applySelectedFont(this, 'trans_text3'); selectFont(); updateOptionValues();">
    <option value="direct">[PC内フォント]</option>
    <option value="M PLUS\\ 1p">M PLUS 1p</option>
    <option value="M PLUS Rounded\\ 1c" selected>M PLUS Rounded 1c</option>
    <option value="Mamelon">マメロン</option>
    <option value="YasashisaB">やさしさB</option>
    <option value="HuiFont29">ふい字</option>
    <option value="Hachi Maru Pop">Hachi Maru Pop</option>
    <option value="MkPOP">851マカポップ</option>
    <option value="bananaslipplus">バナナスリップplus</option>
    <option value="katyou">花鳥風月</option>
    <option value="TanukiMagic">たぬき油性マジック</option>
    <option value="hakidame">吐き溜</option>
    <option value="umeboshi">梅干し</option>
    <option value="Jiyucho">じゆうちょう</option>
    <option value="HitmoR">Hitmo</option>
    <option value="nishikiteki">にしき的</option>
    <option value="Yusei Magic">Yusei Magic</option>
    <option value="Nikumaru">にくまる</option>
    <option value="KTEGAKI">kawaii手書き</option>
    <option value="JKGL">JK Gothic L</option>
    <option value="Reggae One">Reggae One</option>
    <option value="OhisamaFont">おひさま</option>
    <option value="nukamiso">ぬかみそ</option>
    <option value="genkai">源界明朝</option>
    <option value="CP">チェックポイント</option>
    <option value="Noto Sans JP">Noto Sans JP</option>
    <option value="Sawarabi Gothic">さわらびゴシック</option>
    <option value="Nico Moji">ニコモジ</option>
</select>　
PC内フォント：<select id="trans_text3_system_font" onchange="applySystemFont(this.value, 'trans_text3'); updateOptionValues();"></select>
<input type="text" id="trans_text3_direct_font" placeholder="フォント名を入力" style="width: 200px; margin-left: 10px;" disabled oninput="applyDirectFont(this.value, 'trans_text3'); updateOptionValues();"><br>

<HR>
<!-- # 行間調整 ######################### -->
<div style="background-color: #f0f0f0; padding: 8px; border-radius: 5px; margin: 5px 0;">
    <strong>行間：</strong>
    認識→翻訳１
    <input type="range" id="line_spacing_1" min="0" max="50" value="0" 
           oninput="document.getElementById('line_spacing_1_value').textContent = this.value + 'px'; updateLineSpacing('speech_text', this.value); updateOptionValues();"
           style="width: 80px; vertical-align: middle;">
    <span id="line_spacing_1_value" style="display: inline-block; width: 35px; text-align: right;">0px</span>
    　
    翻訳１→２
    <input type="range" id="line_spacing_2" min="0" max="50" value="0" 
           oninput="document.getElementById('line_spacing_2_value').textContent = this.value + 'px'; updateLineSpacing('trans_text', this.value); updateOptionValues();"
           style="width: 80px; vertical-align: middle;">
    <span id="line_spacing_2_value" style="display: inline-block; width: 35px; text-align: right;">0px</span>
    　
    翻訳２→３
    <input type="range" id="line_spacing_3" min="0" max="50" value="0" 
           oninput="document.getElementById('line_spacing_3_value').textContent = this.value + 'px'; updateLineSpacing('trans_text2', this.value); updateOptionValues();"
           style="width: 80px; vertical-align: middle;">
    <span id="line_spacing_3_value" style="display: inline-block; width: 35px; text-align: right;">0px</span>
</div>

<HR>
<!-- # テキストの揃え ######################### -->
テキストの位置：　
左右：
<select id="textAlign" onchange="updateOptionValues()">
    <option value="left">左寄せ</option>
    <option value="center" selected>中央寄せ</option>
    <option value="right">右寄せ</option>
</select>

　上下：
<select id="v_align" onchange="updateOptionValues()">
    <option value="top" selected>上</option>
    <option value="bottom">下</option>
</select><BR>

<!-- # テキストの改行 ######################### -->
テキストの改行：
<select id="whiteSpace" onchange="updateOptionValues()">
    <option value="nowrap">改行しない</option>
    <option value="" selected>画面端で改行</option>
</select><BR>
<HR>


<!-- 音量表示機能は削除されました（音声認識デバイスとの不一致によるユーザー混乱防止のため） -->







<HR>

<!-- # テキスト表示を●秒後に消す ######################### -->
何ミリ秒後に文を消す？　　　：　
<input type="text" name="timer" id="timer" size="10" oninput="updateOptionValues();" />ミリ秒　
<span style="display: inline-block; vertical-align: middle;">
    <!-- 音声認識用タイマーバー（左） -->
    <div id="speechTimerProgressContainer" style="display: inline-block; width: 140px; height: 26px; background: linear-gradient(135deg, #fff5f5 0%, #ffd0cc 100%); border: 2px solid #cc8888; border-radius: 13px; margin-left: 10px; position: relative; overflow: hidden; box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);">
        <div id="speechTimerProgressBar" style="height: 100%; background: linear-gradient(90deg, #FF6B6B 0%, #FFA07A 50%, #FFE4E1 100%); width: 0%; transition: width 0.1s linear; border-radius: 11px; box-shadow: 0 2px 4px rgba(0,0,0,0.2);"></div>
        <div id="speechTimerProgressText" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 13px; font-weight: bold; color: #333; text-shadow: 1px 1px 2px rgba(255,255,255,0.8); letter-spacing: 0.5px;">🎤待機</div>
    </div>
    <!-- 翻訳用タイマーバー（右） -->
    <div id="transTimerProgressContainer" style="display: inline-block; width: 140px; height: 26px; background: linear-gradient(135deg, #f0f8ff 0%, #cce7ff 100%); border: 2px solid #8888cc; border-radius: 13px; margin-left: 8px; position: relative; overflow: hidden; box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);">
        <div id="transTimerProgressBar" style="height: 100%; background: linear-gradient(90deg, #2196F3 0%, #64B5F6 50%, #BBDEFB 100%); width: 0%; transition: width 0.1s linear; border-radius: 11px; box-shadow: 0 2px 4px rgba(0,0,0,0.2);"></div>
        <div id="transTimerProgressText" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 13px; font-weight: bold; color: #333; text-shadow: 1px 1px 2px rgba(255,255,255,0.8); letter-spacing: 0.5px;">🌐待機</div>
    </div>
</span><BR>

<!-- # 文の終わり ######################### -->
何ミリ秒黙ったら文を区切る？：　
<input type="text" name="short_pause" value="750" id="short_pause" size="10" oninput="updateOptionValues();" />ミリ秒（半角数字で入れてね．1000ミリ秒 = 1秒）<BR>
（500：すぐ切る｜750：普通｜1000：つなぐ　調整して．何も入れないと，これまでと同じ動作になる．）<BR>
<HR>


<!-- # 棒読みちゃん連携 ######################### -->
- 棒読みちゃん連携を使う：<input type="checkbox" id="bouyomi" onchange="updateOptionValues()"> ← 使う場合チェック入れる．詳細 → <a target="_blank" href="https://twitter.com/sayonari/status/1386937837682003968">twitter</a><BR>
<!-- # センシティブワード対応する！ ######################### -->
- センシティブワード対応（***に置き換え）を<font color="red">やめる</font>：<input type="checkbox" id="anti_sexual" onchange="updateOptionValues()"> <BR>
<HR>

<!-- # URL view & copy button ############### -->
<!-- URL :  -->
<!-- <textarea name="url" id="url" rows="7" cols="90"></textarea><BR> -->
<!-- 　　　<input type="button" value="copy to clipboard" id="textarea_copy" onclick="document.getElementsByTagName('textarea')[0].select();document.execCommand('copy');"> -->
<!-- 　<a id="open_link" target="_self" href="">[同じタブで開く]</a><BR>
別窓で開くと２つ起動して両方止まるよ！多重起動しないように気をつけて！<BR> -->
<!-- <HR> -->

<!-- # 設定セーブ＆ロードボタン ################## -->
　<button onclick="saveSettings()">設定ファイルをPCに保存</button>　
<button onclick="loadSettings()">設定ファイルをブラウザに読込</button>　：設定が完成したら，設定ファイルを保存しておきましょう　<BR>

<HR>

<!-- # .bat download ボタン ############################## -->
.bat ファイル生成：<BR>
これ使ったら，<font color="red">全画面ゲームしてても止まらない！</font>詳しくはこちら→（<a target="_blank" href="https://www.youtube.com/watch?v=8-UXx_tVeYk">解説動画</a>）<BR>
.batファイルと，設定ファイルをダウンロードしてください．<BR>

<table border="1" style="width: auto;"><tr><td>
<table style="width: auto;">
    <tr>
        <td width="180">Windowsの人：</td>
        <td><button onclick="generateBatFile('win')">Windows用 起動 .batファイル生成</button></td>
        <td><button onclick="saveSettings()">設定ファイルをPCに保存</button></td>
    </tr>
</tr>
</table>
</td></tr></table>
<BR>
    
<table border="1" style="width: auto;"><tr><td>
<table style="width: auto;">
    <tr>
        <td width="180">Macの人：</td>
        <td><button onclick="generateBatFile('mac')">Mac用 起動 .commandファイル生成</button></td>
        <td><button onclick="saveSettings()">設定ファイルをPCに保存</button></td>
    </tr>
</table>
</td></tr></table>

<HR>

<!-- # dummy 見えない数字 ############################## -->
<input style="display: none;" type="text" name="frame_height" id="frame_height" value="30%" size="10" oninput="updateOptionValues();" />


<BR><BR><BR>
</div><BR>

<script>
// Chrome Translation API の状態をチェックして表示を更新
function checkChromeTranslationAPI() {
    // Chrome Translation APIが利用可能かチェック
    if ('Translator' in self) {
        // Chrome Translation APIが利用可能
        document.getElementById('chromeTranslationMode').style.display = 'block';
        document.getElementById('apiModeDisplay').style.display = 'none';
        
        // APIキー入力欄も視覚的に変更
        const apiKeyInput = document.getElementById('gas_key');
        if (apiKeyInput) {
            apiKeyInput.style.backgroundColor = '#f0f0f0';
            apiKeyInput.placeholder = 'Chrome高速翻訳モードのため不要';
        }
        
        // 翻訳ステータスも更新
        const statusEl = document.getElementById('translationStatus');
        if (statusEl) {
            statusEl.textContent = 'Chrome高速モード';
            statusEl.style.color = '#2e7d32';
        }
        
        console.log('🚀 Chrome Translation API (Chrome 138+) 検出 - 高速翻訳モード有効');
        return true;
    } else {
        // Chrome Translation APIが利用不可（通常のGAS APIモード）
        console.log('Chrome Translation APIは利用できません - GAS APIモードで動作');
        return false;
    }
}

// ページ読み込み時にチェック
window.addEventListener('DOMContentLoaded', function() {
    checkChromeTranslationAPI();
    
    // 翻訳方法をlocalStorageから復元
    setTimeout(() => {
        applyTranslationMethodOnLoad();
    }, 100);
    
    // 少し遅延させてから全翻訳モデルをチェック（iframeの準備を待つ）
    setTimeout(() => {
        checkAllTranslationModels();
    }, 2000);
});
</script>

</body>










<!-- # スクリプト ########################################### -->

<!-- # 字幕ちゃん設定項目のロードと，画面への反映 ############################## -->
<script type="text/javascript">
    const currentURL = window.location.origin + window.location.pathname;
    let base_url = currentURL.replace("index.html", "");
    base_url += "main.html?";
    base_url = base_url.replace("??", "?");


    // config 値　一覧 ////////////////
    config_values = ["gas_key", "textAlign", "v_align", "whiteSpace", "bgcolor", "frame_height"
        , "recog", "size1", "weight1", "color1", "st_color1", "st_width1"
        , "trans", "size2", "weight2", "color2", "st_color2", "st_width2"
        , "trans2", "size3", "weight3", "color3", "st_color3", "st_width3"
        , "trans3", "size4", "weight4", "color4", "st_color4", "st_width4"
        , "timer", "short_pause"
        , "bouyomi", "anti_sexual"
        , "speech_text_font_selector", "trans_text_font_selector", "trans_text2_font_selector", "trans_text3_font_selector"
        , "speech_text_system_font", "trans_text_system_font", "trans_text2_system_font", "trans_text3_system_font"
        , "speech_text_direct_font", "trans_text_direct_font", "trans_text2_direct_font", "trans_text3_direct_font"
        , "line_spacing_1", "line_spacing_2", "line_spacing_3"
        , "translation_method"];

    // 新版：全設定はjimakuChan_presetsで管理（jimakuChan_configは廃止）
    // configオブジェクトはプリセット保存時の一時的なデータ収集用のみ
    const config = {};

    // 翻訳画面とURLを初期化 ///////////////
    // 初期読み込み時は設定を反映したURLを生成してから読み込む
    // updateOptionValues(true); // URL生成のみ - DOM要素がまだ存在しないためコメントアウト
    
    // 設定を含むURLでiframeを読み込む
    var initial_url = base_url + "textAlign=" + (config.textAlign || "center") + "&v_align=" + (config.v_align || "bottom")
                    + "&bgcolor=" + (config.bgcolor || "#00ff00")
                    + "&size1=" + (config.size1 || "25") + "&weight1=" + (config.weight1 || "900") + "&color1=" + (config.color1 || "#ffffff")
                    + "&st_color1=" + (config.st_color1 || "#000000") + "&st_width1=" + (config.st_width1 || "6")
                    + "&size2=" + (config.size2 || "25") + "&weight2=" + (config.weight2 || "900") + "&color2=" + (config.color2 || "#ffffff")
                    + "&st_color2=" + (config.st_color2 || "#000000") + "&st_width2=" + (config.st_width2 || "6")
                    + "&size3=" + (config.size3 || "25") + "&weight3=" + (config.weight3 || "900") + "&color3=" + (config.color3 || "#ffffff")
                    + "&st_color3=" + (config.st_color3 || "#000000") + "&st_width3=" + (config.st_width3 || "6")
                    + "&size4=" + (config.size4 || "25") + "&weight4=" + (config.weight4 || "900") + "&color4=" + (config.color4 || "#ffffff")
                    + "&st_color4=" + (config.st_color4 || "#000000") + "&st_width4=" + (config.st_width4 || "6");
    
    console.log('初期読み込み URL:', initial_url);
    document.getElementById('asr_frame').src = initial_url;
    // document.getElementById('url').innerHTML = base_url;
    
    // iframeがロードされた後に設定を反映
    document.getElementById('asr_frame').onload = function() {
        console.log('iframe読み込み完了');
        setTimeout(applyInitialSettings, 300);
    };
    // frame_heightの初期化はプリセット読み込み後に行うため、ここでは削除
    // applyFrameHeight関数で処理される


    // フォントの直接入力の場合，テキストフィールドを有効化、システムフォントプルダウンを制御 ////////////////////
    function selectFont() {
        var speech_text_font_selector = document.getElementById('speech_text_font_selector').value;
        var trans_text_font_selector = document.getElementById('trans_text_font_selector').value;
        var trans_text2_font_selector = document.getElementById('trans_text2_font_selector').value;
        var trans_text3_font_selector = document.getElementById('trans_text3_font_selector').value;
        
        console.log("フォント選択状態: " + speech_text_font_selector);
        
        // 音声認識フォント
        var speechSystemFont = document.getElementById('speech_text_system_font');
        if (speech_text_font_selector === "direct") {
            if (speechSystemFont) {
                speechSystemFont.disabled = false;
                speechSystemFont.style.backgroundColor = '';
                speechSystemFont.style.color = '';
            }
        } else {
            if (speechSystemFont) {
                speechSystemFont.disabled = true;
                speechSystemFont.style.backgroundColor = '#f0f0f0';
                speechSystemFont.style.color = '#999';
                speechSystemFont.value = ''; // 選択をクリア
            }
        }

        // 翻訳1フォント
        var transSystemFont = document.getElementById('trans_text_system_font');
        if (trans_text_font_selector === "direct") {
            if (transSystemFont) {
                transSystemFont.disabled = false;
                transSystemFont.style.backgroundColor = '';
                transSystemFont.style.color = '';
            }
        } else {
            if (transSystemFont) {
                transSystemFont.disabled = true;
                transSystemFont.style.backgroundColor = '#f0f0f0';
                transSystemFont.style.color = '#999';
                transSystemFont.value = '';
            }
        }

        // 翻訳2フォント
        var trans2SystemFont = document.getElementById('trans_text2_system_font');
        if (trans_text2_font_selector === "direct") {
            if (trans2SystemFont) {
                trans2SystemFont.disabled = false;
                trans2SystemFont.style.backgroundColor = '';
                trans2SystemFont.style.color = '';
            }
        } else {
            if (trans2SystemFont) {
                trans2SystemFont.disabled = true;
                trans2SystemFont.style.backgroundColor = '#f0f0f0';
                trans2SystemFont.style.color = '#999';
                trans2SystemFont.value = '';
            }
        }

        // 翻訳3フォント
        var trans3SystemFont = document.getElementById('trans_text3_system_font');
        if (trans_text3_font_selector === "direct") {
            if (trans3SystemFont) {
                trans3SystemFont.disabled = false;
                trans3SystemFont.style.backgroundColor = '';
                trans3SystemFont.style.color = '';
            }
        } else {
            if (trans3SystemFont) {
                trans3SystemFont.disabled = true;
                trans3SystemFont.style.backgroundColor = '#f0f0f0';
                trans3SystemFont.style.color = '#999';
                trans3SystemFont.value = '';
            }
        }

        updateOptionValues();
    }
    
    // 初期設定の反映
    selectFont();
    // PC内フォントと直接入力フィールドの初期状態を設定
    initializeSystemFontFields();
    
    // プリセット初期化は最下部で実行

    // 初期設定を適用する関数
    function applyInitialSettings() {
        try {
            // iframe内のドキュメントが準備できるまで待つ
            if (document.getElementById('asr_frame').contentWindow && 
                document.getElementById('asr_frame').contentWindow.document) {
                
                console.log('初期設定を適用中...');
                
                // まず設定をURLパラメータで更新（iframe再読み込み）
                updateOptionValues(false);
                
                // 少し待ってからDOMの直接操作も実行
                setTimeout(function() {
                    applyAllSettings();
                    // スライドバー数値表示を更新
                    updateVisualSettings();
                    // ページタイトルを更新
                    updatePageTitle();
                    console.log('初期設定適用完了');
                }, 200);
                
            } else {
                // まだ準備できていない場合は少し待ってから再試行
                setTimeout(applyInitialSettings, 100);
            }
        } catch (error) {
            console.error('初期設定適用エラー:', error);
            // エラーが発生した場合も再試行
            setTimeout(applyInitialSettings, 200);
        }
    }

    // 翻訳方法の切り替え処理
    function switchTranslationMethod() {
        const chromeRadio = document.getElementById('translationMethodChrome');
        const gasRadio = document.getElementById('translationMethodGas');
        const notice = document.getElementById('chromeTranslationNotice');
        const modelArea = document.getElementById('modelDownloadArea');
        
        if (chromeRadio.checked) {
            // Chrome内蔵翻訳選択時
            notice.style.display = 'block';
            // モデルダウンロードエリアの表示状態を確認するためチェック実行
            checkAllTranslationModels();
            
            // iframe内に翻訳方法変更を通知（タイマー開始のため）
            updateTranslationMethodInIframe('chrome');
        } else {
            // GAS API選択時
            notice.style.display = 'none';
            if (modelArea) {
                modelArea.style.display = 'none';
            }
            
            // iframe内に翻訳方法変更を通知（タイマー停止のため）
            updateTranslationMethodInIframe('gas');
        }
        
        // localStorage に保存
        const selectedMethod = chromeRadio.checked ? 'chrome' : 'gas';
        saveTranslationMethodToStorage(selectedMethod);
        
        // プリセットに自動保存
        updateOptionValues();
    }
    
    // iframe内の翻訳方法設定を更新
    function updateTranslationMethodInIframe(method = null) {
        const iframe = document.getElementById('asr_frame');
        if (!iframe || !iframe.contentWindow) {
            console.warn('iframe未準備のため翻訳方法更新をスキップ');
            return;
        }
        
        try {
            const selectedMethod = method || document.querySelector('input[name="translationMethod"]:checked').value;
            iframe.contentWindow.postMessage({
                type: 'updateTranslationMethod',
                method: selectedMethod
            }, '*');
            console.log(`翻訳方法を${selectedMethod}に更新しました（タイマー${selectedMethod === 'chrome' ? '開始' : '停止'}）`);
        } catch (error) {
            console.error('iframe内の翻訳方法更新エラー:', error);
        }
    }
    
    function setupMessageListener() {
        window.addEventListener('message', function(event) {
            if (event.data && event.data.type === 'chromeTranslationCountdown') {
                const timerElement = document.getElementById('chromeTranslationTimer');
                
                if (timerElement) {
                    const { remainingMinutes, remainingSeconds, totalSeconds } = event.data;
                    
                    if (totalSeconds > 0) {
                        const minutes = String(remainingMinutes).padStart(2, '0');
                        const seconds = String(remainingSeconds).padStart(2, '0');
                        timerElement.textContent = `（${minutes}:${seconds}後にリロード）`;
                    } else {
                        timerElement.textContent = '（待機中）';
                    }
                }
            }
        }, false);
    }
    
    
    // localStorage保存・読み込み機能
    function saveTranslationMethodToStorage(method) {
        try {
            localStorage.setItem('jimakuChan_translationMethod', method);
            console.log('翻訳方法をlocalStorageに保存:', method);
        } catch (error) {
            console.warn('翻訳方法のlocalStorage保存に失敗:', error);
        }
    }
    
    function loadTranslationMethodFromStorage() {
        try {
            const saved = localStorage.getItem('jimakuChan_translationMethod');
            return saved || 'chrome'; // デフォルトはChrome内蔵
        } catch (error) {
            console.warn('翻訳方法のlocalStorage読み込みに失敗:', error);
            return 'chrome';
        }
    }
    
    // 初期化時に翻訳方法の値を取得する関数
    function getTranslationMethod() {
        const chromeRadio = document.getElementById('translationMethodChrome');
        if (!chromeRadio) {
            // ラジオボタンがまだ存在しない場合はlocalStorageから取得
            return loadTranslationMethodFromStorage();
        }
        return chromeRadio.checked ? 'chrome' : 'gas';
    }
    
    // ページ読み込み時に翻訳方法を復元する関数
    function applyTranslationMethodOnLoad() {
        const savedMethod = loadTranslationMethodFromStorage();
        
        const chromeRadio = document.getElementById('translationMethodChrome');
        const gasRadio = document.getElementById('translationMethodGas');
        const notice = document.getElementById('chromeTranslationNotice');
        
        if (chromeRadio && gasRadio && notice) {
            // ラジオボタンの状態を設定
            if (savedMethod === 'chrome') {
                chromeRadio.checked = true;
                gasRadio.checked = false;
                notice.style.display = 'block';
            } else {
                chromeRadio.checked = false;
                gasRadio.checked = true;
                notice.style.display = 'none';
            }
            
            // iframe内にも通知
            updateTranslationMethodInIframe();
            
            console.log('翻訳方法をlocalStorageから復元:', savedMethod);
        }
    }
    
    // iframe内の翻訳言語を動的に更新
    function updateTranslationLanguageInIframe(transNum, newLang) {
        const iframe = document.getElementById('asr_frame');
        if (!iframe || !iframe.contentWindow) return;
        
        try {
            // iframe内のグローバル変数を更新
            if (transNum === 1) {
                iframe.contentWindow.arg_trans = newLang === 'none' ? null : newLang;
            } else if (transNum === 2) {
                iframe.contentWindow.arg_trans2 = newLang === 'none' ? null : newLang;
            } else if (transNum === 3) {
                iframe.contentWindow.arg_trans3 = newLang === 'none' ? null : newLang;
            }
            
            console.log(`翻訳言語${transNum}を${newLang}に更新しました`);
        } catch (error) {
            console.error('iframe内の翻訳言語更新エラー:', error);
        }
    }
    
    // URLに付けるオプションの値をアップデート //////////
    function updateOptionValues(only_url=false, transNum=null) {
        for (const p of config_values) {
            // translation_methodは特別処理なのでスキップ
            if (p === 'translation_method') {
                continue;
            }
            const element = document.getElementById(p);
            if (element) {
                eval("var " + p + " = element.value;");
            }
        }
        var bouyomi = document.getElementById('bouyomi').checked;
        var anti_sexual = document.getElementById('anti_sexual').checked;
        var translation_method = getTranslationMethod();
        
        // フォント変数の初期化
        var speech_text_font = '';
        var trans_text_font = '';
        var trans_text2_font = '';
        var trans_text3_font = '';

        var new_url = base_url + "textAlign=" + textAlign + "&v_align=" + v_align 
                     + "&recog=" + recog 
                     + "&bgcolor=" + bgcolor

                     + "&size1=" + size1 + "&weight1=" + weight1 + "&color1=" + color1
                     + "&st_color1=" + st_color1 + "&st_width1=" + st_width1

                     + "&size2=" + size2 + "&weight2=" + weight2 + "&color2=" + color2
                     + "&st_color2=" + st_color2 + "&st_width2=" + st_width2

                     + "&size3=" + size3 + "&weight3=" + weight3 + "&color3=" + color3
                     + "&st_color3=" + st_color3 + "&st_width3=" + st_width3

                     + "&size4=" + size4 + "&weight4=" + weight4 + "&color4=" + color4
                     + "&st_color4=" + st_color4 + "&st_width4=" + st_width4;
        if(whiteSpace != '') {new_url = new_url + "&whiteSpace=" + whiteSpace;} 
        if(trans != 'none') {new_url = new_url + "&trans=" + trans;} 
        if(trans2 != 'none') {new_url = new_url + "&trans2=" + trans2;} 
        if(trans3 != 'none') {new_url = new_url + "&trans3=" + trans3;} 

        // font の処理
        console.log('[DEBUG] Font processing:', {
            speech_text_font_selector,
            speech_text_system_font,
            speech_text_direct_font
        });
        if (speech_text_font_selector !== "direct") {
            speech_text_font = speech_text_font_selector;
        } else {
            // 直接指定の場合、直接入力の値を優先、なければシステムフォントの値を使用
            // ただし、システムフォントの値が'direct'の場合は無視
            if (speech_text_direct_font && speech_text_direct_font !== '') {
                speech_text_font = speech_text_direct_font;
            } else if (speech_text_system_font && speech_text_system_font !== '' && speech_text_system_font !== 'direct') {
                speech_text_font = speech_text_system_font;
            } else {
                speech_text_font = '';
            }
            console.log('[DEBUG] Direct font selected:', speech_text_font);
        }
        if (trans_text_font_selector !== "direct") {
            trans_text_font = trans_text_font_selector;
        } else {
            if (trans_text_direct_font && trans_text_direct_font !== '') {
                trans_text_font = trans_text_direct_font;
            } else if (trans_text_system_font && trans_text_system_font !== '' && trans_text_system_font !== 'direct') {
                trans_text_font = trans_text_system_font;
            } else {
                trans_text_font = '';
            }
        }
        if (trans_text2_font_selector !== "direct") {
            trans_text2_font = trans_text2_font_selector;
        } else {
            if (trans_text2_direct_font && trans_text2_direct_font !== '') {
                trans_text2_font = trans_text2_direct_font;
            } else if (trans_text2_system_font && trans_text2_system_font !== '' && trans_text2_system_font !== 'direct') {
                trans_text2_font = trans_text2_system_font;
            } else {
                trans_text2_font = '';
            }
        }
        if (trans_text3_font_selector !== "direct") {
            trans_text3_font = trans_text3_font_selector;
        } else {
            if (trans_text3_direct_font && trans_text3_direct_font !== '') {
                trans_text3_font = trans_text3_direct_font;
            } else if (trans_text3_system_font && trans_text3_system_font !== '' && trans_text3_system_font !== 'direct') {
                trans_text3_font = trans_text3_system_font;
            } else {
                trans_text3_font = '';
            }
        }
        if(speech_text_font != '') {
            new_url = new_url + "&speech_text_font=" + speech_text_font;
            console.log('[DEBUG] Adding speech_text_font to URL:', speech_text_font);
        } else {
            console.log('[DEBUG] speech_text_font is empty, not adding to URL');
        } 
        if(trans_text_font != '') {new_url = new_url + "&trans_text_font=" + trans_text_font;} 
        if(trans_text2_font != '') {new_url = new_url + "&trans_text2_font=" + trans_text2_font;} 
        if(trans_text3_font != '') {new_url = new_url + "&trans_text3_font=" + trans_text3_font;} 

        if(timer != '') {new_url = new_url + "&timer=" + timer;} 
        if(short_pause != '') {new_url = new_url + "&short_pause=" + short_pause;}
        
        // 行間設定
        if(line_spacing_1 != '') {new_url = new_url + "&line_spacing_1=" + line_spacing_1;}
        if(line_spacing_2 != '') {new_url = new_url + "&line_spacing_2=" + line_spacing_2;}
        if(line_spacing_3 != '') {new_url = new_url + "&line_spacing_3=" + line_spacing_3;} 

        if(bouyomi == true) {new_url = new_url + "&bouyomi=" + bouyomi;}
        // anti_sexualは、チェックON=削除をやめる(false)、チェックOFF=削除する(true)
        if(anti_sexual == true) {
            new_url = new_url + "&anti_sexual=" + "false";
        } else {
            new_url = new_url + "&anti_sexual=" + "true";
        }
        if(gas_key != '') {new_url = new_url + "&gas_key=" + gas_key;}
        if(translation_method != '') {new_url = new_url + "&translation_method=" + translation_method;}
   
        // config の更新
        for (const p of config_values) {
            config[p] = eval(p);
        }
        
        // checkbox設定もconfigに追加（プリセット保存用のみ）
        config.bouyomi = bouyomi;
        config.anti_sexual = anti_sexual;
        config.translation_method = translation_method;

        // 注意：jimakuChan_configへの保存は廃止。全てプリセットで管理

        // プリセットへの自動保存（プリセット読み込み中でなければ実行）
        console.log('updateOptionValues - 自動保存チェック:', 'isLoadingPreset:', isLoadingPreset, 'currentPreset:', currentPreset);
        if (!isLoadingPreset) {
            console.log('自動保存スケジュール - 100ms後に実行');
            setTimeout(saveCurrentPreset, 100);
        } else {
            console.log('自動保存スキップ - プリセット読み込み中');
        }

        // ページタイトルの更新
        updatePageTitle();

        // 認識ちゃん画面の更新 ///////
        if(only_url == false) {
            // 翻訃言語変更時はiframe内の変数を更新（リロードせず）
            if (transNum !== null) {
                if (transNum === 1) {
                    updateTranslationLanguageInIframe(1, trans);
                } else if (transNum === 2) {
                    updateTranslationLanguageInIframe(2, trans2);
                } else if (transNum === 3) {
                    updateTranslationLanguageInIframe(3, trans3);
                }
            } else {
                // 翻訳言語以外の変更時はリロード
                console.log('iframe更新 URL:', new_url);
                document.getElementById('asr_frame').src = new_url;
            }
        }

        // document.getElementById('url').innerHTML = new_url;
        // document.getElementById('open_link').href = new_url;

        return 0;
    }

    // ページタイトルを更新する関数
    function updatePageTitle() {
        try {
            const presetSelect = document.getElementById('presetSelect');
            if (presetSelect && presetSelect.selectedIndex > 0) {
                const selectedText = presetSelect.options[presetSelect.selectedIndex].text;
                document.title = `jimakuChan: 音声認識字幕ちゃん [${selectedText}]`;
            } else {
                document.title = 'jimakuChan: 音声認識字幕ちゃん [CONFIG]';
            }
        } catch (error) {
            console.log('タイトル更新エラー:', error);
            document.title = 'jimakuChan: 音声認識字幕ちゃん [CONFIG]';
        }
    }

    // 初期化時は遅延実行
    setTimeout(function() {
        updateOptionValues();
    }, 100);

    // PCにインストールされているフォントを検出する関数
    function detectSystemFonts() {
        // よく使われるシステムフォントのリスト（拡張版）
        const commonFonts = [
            // 日本語フォント - Windows
            'Yu Gothic', 'Yu Gothic UI', 'Yu Gothic Medium', 'Yu Mincho', 'Meiryo', 'Meiryo UI',
            'MS Gothic', 'MS PGothic', 'MS UI Gothic', 'MS Mincho', 'MS PMincho',
            'BIZ UDGothic', 'BIZ UDPGothic', 'BIZ UDMincho', 'BIZ UDPMincho',
            'UD Digi Kyokasho', 'UD Digi Kyokasho N-R', 'UD Digi Kyokasho NK-R',
            
            // 日本語フォント - Mac
            'Hiragino Sans', 'Hiragino Kaku Gothic ProN', 'Hiragino Kaku Gothic Pro',
            'Hiragino Mincho ProN', 'Hiragino Mincho Pro', 'Hiragino Maru Gothic ProN',
            'Osaka', 'Osaka-Mono', 'Tsukushi A Round Gothic', 'Tsukushi B Round Gothic',
            'YuKyokasho', 'YuKyokasho Yoko', 'Klee',
            
            // 日本語フォント - 共通/Web
            'Noto Sans JP', 'Noto Sans CJK JP', 'Noto Serif JP', 'Noto Serif CJK JP',
            'Source Han Sans', 'Source Han Serif', '源ノ角ゴシック', '源ノ明朝',
            'Sawarabi Gothic', 'Sawarabi Mincho', 'Kosugi', 'Kosugi Maru',
            'M PLUS 1p', 'M PLUS Rounded 1c', 'M PLUS 2',
            
            // 英語フォント - 基本
            'Arial', 'Arial Black', 'Arial Narrow', 'Arial Unicode MS',
            'Helvetica', 'Helvetica Neue', 'Times New Roman', 'Georgia',
            'Verdana', 'Tahoma', 'Trebuchet MS', 'Comic Sans MS',
            'Courier', 'Courier New', 'Lucida Console', 'Consolas',
            
            // 英語フォント - 追加
            'Calibri', 'Cambria', 'Candara', 'Century', 'Century Gothic',
            'Franklin Gothic', 'Futura', 'Garamond', 'Gill Sans',
            'Impact', 'Lucida Grande', 'Lucida Sans', 'Monaco',
            'Palatino', 'Palatino Linotype', 'Segoe UI', 'Segoe Print',
            
            // システムフォント
            'system-ui', '-apple-system', 'BlinkMacSystemFont',
            'SF Pro Display', 'SF Pro Text', 'SF Mono',
            '.AppleSystemUIFont', 'Apple Color Emoji',
            'Segoe UI Emoji', 'Segoe UI Symbol', 'Roboto',
            
            // 追加の装飾フォント
            'HGP創英角ｺﾞｼｯｸUB', 'HGP創英角ﾎﾟｯﾌﾟ体', 'HGP教科書体', 'HGPｺﾞｼｯｸE',
            'HGPｺﾞｼｯｸM', 'HGP明朝E', 'HGS創英角ｺﾞｼｯｸUB', 'HGS創英角ﾎﾟｯﾌﾟ体',
            'DF平成明朝体', 'DF平成ゴシック体', 'DFP平成明朝体', 'DFP平成ゴシック体'
        ];

        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        const testString = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789あいうえおカキクケコ漢字';
        
        // ベースライン（デフォルトフォント）のサイズを測定
        context.font = '12px monospace';
        const baselineWidth = context.measureText(testString).width;
        
        const availableFonts = [];
        
        for (const font of commonFonts) {
            context.font = `12px "${font}", monospace`;
            const width = context.measureText(testString).width;
            
            // ベースラインと幅が異なれば、そのフォントが利用可能
            if (width !== baselineWidth) {
                availableFonts.push(font);
            }
        }
        
        return availableFonts;
    }

    // フォント選択プルダウンを初期化する関数
    function initializeFontSelectors() {
        const availableFonts = detectSystemFonts();
        const fontSelectors = ['speech_text_system_font', 'trans_text_system_font', 'trans_text2_system_font', 'trans_text3_system_font'];
        
        fontSelectors.forEach(selectorId => {
            const selector = document.getElementById(selectorId);
            if (selector) {
                // 既存のオプションをクリア
                selector.innerHTML = '';
                
                // デフォルトオプションを追加
                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = '選択してください';
                selector.appendChild(defaultOption);
                
                // [直接指定]オプションを追加
                const directOption = document.createElement('option');
                directOption.value = 'direct';
                directOption.textContent = '[直接指定]';
                selector.appendChild(directOption);
                
                // 検出されたフォントを追加
                availableFonts.forEach(font => {
                    const option = document.createElement('option');
                    option.value = font;
                    option.textContent = font;
                    option.style.fontFamily = font;
                    selector.appendChild(option);
                });
            }
        });
        
        // 初期化後に状態を正しく設定
        setTimeout(selectFont, 100);
    }

    // フォントステータスを更新する関数
    function updateFontStatus(message, color) {
        const statusElement = document.getElementById('font_api_status');
        if (!statusElement) return;
        
        statusElement.innerHTML = message;
        statusElement.style.color = color || '#666';
        console.log('フォントステータス:', message);
    }
    
    // Font Access API対応状況をチェックして表示する関数（表示を無効化）
    function checkFontAPIStatus() {
        if ('queryLocalFonts' in window) {
            // updateFontStatus('Font Access API対応（実験的機能）', '#008000');
            
            // 実際に使えるかテスト
            window.queryLocalFonts().then(fonts => {
                // updateFontStatus(`Font Access API対応（${fonts.length}個のフォント検出）`, '#008000');
            }).catch(error => {
                // updateFontStatus('Font Access API（権限エラー）', '#ff6600');
            });
        } else {
            // updateFontStatus('限定リスト使用中（Font Access API非対応）', '#666');
        }
    }
    
    // 直接指定フォントを適用する関数
    // フォントが実際に存在するかをチェックする関数
    function checkFontExists(fontName) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        const testString = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789あいうえおカキクケコ漢字';
        
        // ベースライン（確実に存在するフォント）のサイズを測定
        context.font = '12px monospace';
        const monoWidth = context.measureText(testString).width;
        
        context.font = '12px sans-serif';
        const sansWidth = context.measureText(testString).width;
        
        // 指定されたフォントで測定
        context.font = `12px "${fontName}", monospace`;
        const testWidth = context.measureText(testString).width;
        
        // monospaceと同じ幅なら、フォントが見つからずフォールバックされた可能性が高い
        return testWidth !== monoWidth;
    }

    function applyDirectFont(fontName, targetElement) {
        if (!fontName || !targetElement) return;
        
        try {
            const iframe = document.getElementById('asr_frame');
            if (!iframe || !iframe.contentWindow || !iframe.contentWindow.document) {
                console.log('iframe not ready, font will be applied later');
                updateFontStatus('⏳ iframe準備中...', '#ff6600');
                return;
            }
            
            const iframeDoc = iframe.contentWindow.document;
            const element = iframeDoc.getElementById(targetElement);
            
            if (element) {
                // フォント名の大文字小文字を調整（Kleeなど）
                if (fontName.toLowerCase() === 'klee') {
                    fontName = 'Klee';
                }
                
                // フォントを適用
                const fontFamily = `"${fontName}", sans-serif`;
                element.style.fontFamily = fontFamily;
                
                // 子要素にも適用（-bg, -fg, -imb）
                const bgElement = iframeDoc.getElementById(targetElement + '-bg');
                const fgElement = iframeDoc.getElementById(targetElement + '-fg');
                const imbElement = iframeDoc.getElementById(targetElement + '-imb');
                
                if (bgElement) bgElement.style.fontFamily = fontFamily;
                if (fgElement) fgElement.style.fontFamily = fontFamily;
                if (imbElement) imbElement.style.fontFamily = fontFamily;
                
                console.log(`直接指定フォント適用: ${fontName} → ${targetElement}`);
                
                // フォントが実際に存在するかチェック
                const fontExists = checkFontExists(fontName);
                
                if (fontExists) {
                    // さらに実際に適用されたかを確認
                    const computedStyle = iframeDoc.defaultView.getComputedStyle(element);
                    const appliedFont = computedStyle.fontFamily;
                    
                    if (appliedFont.includes(fontName)) {
                        // updateFontStatus(`✅ 直接指定: ${fontName}`, '#008000');
                    } else {
                        // updateFontStatus(`⚠️ 直接指定: ${fontName} (部分的に適用)`, '#ff6600');
                    }
                } else {
                    // updateFontStatus(`❌ フォントなしエラー 直接指定: ${fontName}`, '#cc0000');
                }
            }
        } catch (error) {
            console.log('直接指定フォント適用エラー:', error);
            // updateFontStatus(`❌ エラー: ${error.message}`, '#cc0000');
        }
    }
    
    // システムフォントを適用する関数
    function applySystemFont(fontName, targetElement) {
        // 対応する直接入力フィールドを取得
        const directFontInput = document.getElementById(targetElement + '_direct_font');
        
        if (fontName === 'direct') {
            // [直接指定]が選ばれた場合、テキストフィールドを有効化
            if (directFontInput) {
                directFontInput.disabled = false;
                directFontInput.style.backgroundColor = '';
                directFontInput.style.color = '';
                directFontInput.focus();
            }
        } else {
            // それ以外の場合、テキストフィールドを無効化してクリア
            if (directFontInput) {
                directFontInput.disabled = true;
                directFontInput.style.backgroundColor = '#f0f0f0';
                directFontInput.style.color = '#999';
                directFontInput.value = '';
            }
            
            // 選択されたフォントを適用
            if (fontName && fontName !== '') {
                try {
                    const iframe = document.getElementById('asr_frame');
                    if (!iframe || !iframe.contentWindow || !iframe.contentWindow.document) {
                        console.log('iframe not ready, font will be applied later');
                        return;
                    }
                    
                    const iframeDoc = iframe.contentWindow.document;
                    const element = iframeDoc.getElementById(targetElement);
                    if (element) {
                        // フォント名の大文字小文字を調整（Kleeなど）
                        if (fontName.toLowerCase() === 'klee') {
                            fontName = 'Klee';
                        }
                        
                        const fontFamily = `"${fontName}", sans-serif`;
                        element.style.fontFamily = fontFamily;
                        
                        // 子要素にも適用（-bg, -fg, -imb）
                        const bgElement = iframeDoc.getElementById(targetElement + '-bg');
                        const fgElement = iframeDoc.getElementById(targetElement + '-fg');
                        const imbElement = iframeDoc.getElementById(targetElement + '-imb');
                        
                        if (bgElement) bgElement.style.fontFamily = fontFamily;
                        if (fgElement) fgElement.style.fontFamily = fontFamily;
                        if (imbElement) imbElement.style.fontFamily = fontFamily;
                        
                        console.log(`システムフォント適用: ${fontName} → ${targetElement}`);
                        
                        // フォントが実際に適用されたかチェック
                        const computedStyle = iframe.contentWindow.document.defaultView.getComputedStyle(element);
                        const appliedFont = computedStyle.fontFamily;
                        
                        if (appliedFont.includes(fontName)) {
                            // updateFontStatus(`✅ PC内フォント: ${fontName}`, '#008000');
                        } else {
                            // updateFontStatus(`⚠️ PC内フォント: ${fontName} (未検出)`, '#ff6600');
                        }
                    }
                } catch (error) {
                    console.log('システムフォント適用エラー:', error);
                }
            }
        }
    }

    // PC内フォントと直接入力フィールドの状態を初期化する関数
    function initializeSystemFontFields() {
        const fontTargets = ['speech_text', 'trans_text', 'trans_text2', 'trans_text3'];
        
        fontTargets.forEach(target => {
            const systemFontSelect = document.getElementById(target + '_system_font');
            const directFontInput = document.getElementById(target + '_direct_font');
            
            if (systemFontSelect && directFontInput) {
                // 保存された値がある場合は復元
                const savedSystemFont = systemFontSelect.value;
                const savedDirectFont = directFontInput.value;
                
                // 直接入力フィールドの状態を設定
                if (savedSystemFont === 'direct') {
                    // [直接指定]が選択されている場合は、フォント名が空でも有効化
                    directFontInput.disabled = false;
                    directFontInput.style.backgroundColor = '';
                    directFontInput.style.color = '';
                    // 直接入力されたフォントがある場合のみ適用
                    if (savedDirectFont) {
                        applyDirectFont(savedDirectFont, target);
                    }
                } else {
                    directFontInput.disabled = true;
                    directFontInput.style.backgroundColor = '#f0f0f0';
                    directFontInput.style.color = '#999';
                    // システムフォントを適用
                    if (savedSystemFont && savedSystemFont !== '' && savedSystemFont !== 'direct') {
                        applySystemFont(savedSystemFont, target);
                    }
                }
            }
        });
    }
    
    // 行間をリアルタイムで更新する関数
    function updateLineSpacing(targetElement, spacing) {
        try {
            const iframe = document.getElementById('asr_frame');
            if (!iframe || !iframe.contentWindow || !iframe.contentWindow.document) {
                console.log('iframe not ready for line spacing update');
                return;
            }
            
            const element = iframe.contentWindow.document.getElementById(targetElement);
            if (element) {
                element.style.marginBottom = spacing + 'px';
                console.log(`行間更新: ${targetElement} → ${spacing}px`);
            }
        } catch (error) {
            console.log('行間更新エラー:', error);
        }
    }
    
    // 選択されたフォントを適用する関数
    function applySelectedFont(selector, targetElement) {
        try {
            const iframe = document.getElementById('asr_frame');
            if (!iframe || !iframe.contentWindow || !iframe.contentWindow.document) {
                console.log('iframe not ready, font will be applied later');
                return;
            }
            
            let fontValue = selector.value;
            
            // "direct"の場合は何もしない（システムフォント選択で処理）
            if (fontValue === 'direct') {
                return;
            }
            
            // directでない場合、直接入力フィールドをクリア
            const directFontInput = document.getElementById(targetElement + '_direct_font');
            if (directFontInput) {
                directFontInput.value = '';
            }
            
            // バックスラッシュを除去してフォント名を正規化
            fontValue = fontValue.replace(/\\\\/g, '');
            
            const iframeDoc = iframe.contentWindow.document;
            const element = iframeDoc.getElementById(targetElement);
            if (element) {
                const fontFamily = `"${fontValue}", sans-serif`;
                element.style.fontFamily = fontFamily;
                
                // 子要素にも適用（-bg, -fg, -imb）
                const bgElement = iframeDoc.getElementById(targetElement + '-bg');
                const fgElement = iframeDoc.getElementById(targetElement + '-fg');
                const imbElement = iframeDoc.getElementById(targetElement + '-imb');
                
                if (bgElement) bgElement.style.fontFamily = fontFamily;
                if (fgElement) fgElement.style.fontFamily = fontFamily;
                if (imbElement) imbElement.style.fontFamily = fontFamily;
                
                console.log(`フォント適用: ${fontValue} → ${targetElement}`);
                // updateFontStatus(`✅ フォント: ${fontValue}`, '#008000');
            }
        } catch (error) {
            console.log('フォント適用エラー:', error);
        }
    }

    // テキストの色変え ---------------------------
    function changeTextColor(type, color, id) {
        try {
            var iframe = document.getElementById('asr_frame');
            if (!iframe || !iframe.contentWindow || !iframe.contentWindow.document) {
                return;
            }
            
            var text_layer = ['fg','bg','imb'];
            var lang_line = ['speech_text','trans_text','trans_text2','trans_text3'];
            var element = iframe.contentWindow.document.getElementById(lang_line[id-1] + '-' + type);

            if (element) {
                if(type == "fg") { 
                    element.style.color = color;
                } else { 
                    element.style.webkitTextStrokeColor = color; 
                }
            }

            // type が imb の場合は，全てのlang_lineに反映
            if(type == "imb") {
                for (const ll of lang_line){
                    var imbElement = iframe.contentWindow.document.getElementById(ll + '-' + type);
                    if (imbElement) {
                        imbElement.style.webkitTextStrokeColor = color;
                        imbElement.style.color = color;
                    }
                } 
            }
        } catch (error) {
            console.error('色変更エラー:', error);
        }
    }

    function setTextBorder(width, id) {
        try {
            var iframe = document.getElementById('asr_frame');
            if (!iframe || !iframe.contentWindow || !iframe.contentWindow.document) {
                return;
            }
            
            var lang_line = ['speech_text','trans_text','trans_text2','trans_text3'];
            var bgElement = iframe.contentWindow.document.getElementById(lang_line[id-1] + "-bg");
            var imbElement = iframe.contentWindow.document.getElementById(lang_line[id-1] + "-imb");

            if (bgElement) {
                bgElement.style.webkitTextStrokeWidth = width + 'pt';
            }
            if (imbElement) {
                imbElement.style.webkitTextStrokeWidth = width + 'pt';
            }
        } catch (error) {
            console.error('ボーダー設定エラー:', error);
        }
   }

    function changeText(text, id){
        var text_layer = ['fg','bg','imb'];
        var lang_line = ['speech_text','trans_text','trans_text2','trans_text3'];

        for (const tl of text_layer){ 
            document.getElementById('asr_frame').contentWindow.document.getElementById(ll[id-1] + '-' + tl).innerHTML = text;
        }         
    }
    
    // 全ての設定を適用する関数
    function applyAllSettings() {
        try {
            var iframe = document.getElementById('asr_frame');
            if (!iframe || !iframe.contentWindow || !iframe.contentWindow.document) {
                console.log('iframe未準備のため設定適用をスキップ');
                return false;
            }
            
            var iframeDoc = iframe.contentWindow.document;
            
            // 背景色
            var bgcolor = document.getElementById('bgcolor').value;
            if (bgcolor) {
                iframeDoc.bgColor = bgcolor;
            }
            
            // テキストアライメント
            var v_align = document.getElementById('v_align').value;
            var textTable = iframeDoc.getElementById("text_table");
            if (textTable) {
                if (v_align == "top"){
                    textTable.style.bottom = -1;
                } else if(v_align == "bottom"){
                    textTable.style.bottom = 0;
                }
            }
            
            var textAlign = document.getElementById('textAlign').value;
            if (textTable && textAlign) {
                textTable.style.textAlign = textAlign;
                var tblTd = iframeDoc.getElementById("tbl_td");
                if (tblTd) {
                    tblTd.style.textAlign = textAlign;
                    if(textAlign == "right"){
                        textTable.style.direction = "rtl";
                        tblTd.style.direction = "rtl";
                        iframeDoc.body.style.direction = "rtl";
                    }
                }
            }
            
            // 各テキストレイヤーの色とサイズを更新
            for (var i = 1; i <= 4; i++) {
                changeTextColor('fg', document.getElementById('color' + i).value, i);
                changeTextColor('bg', document.getElementById('st_color' + i).value, i);
                setTextBorder(document.getElementById('st_width' + i).value, i);
                
                var lang_line = ['speech_text','trans_text','trans_text2','trans_text3'];
                var textElement = iframeDoc.getElementById(lang_line[i-1]);
                if (textElement) {
                    textElement.style.fontSize = document.getElementById('size' + i).value + 'pt';
                    textElement.style.fontWeight = document.getElementById('weight' + i).value;
                    
                    // フォント設定
                    var fontSelectorIds = ['speech_text_font_selector', 'trans_text_font_selector', 'trans_text2_font_selector', 'trans_text3_font_selector'];
                    var systemFontIds = ['speech_text_system_font', 'trans_text_system_font', 'trans_text2_system_font', 'trans_text3_system_font'];
                    
                    var fontSelector = document.getElementById(fontSelectorIds[i-1]);
                    var systemFontSelector = document.getElementById(systemFontIds[i-1]);
                    
                    if (fontSelector) {
                        if (fontSelector.value === 'direct' && systemFontSelector && systemFontSelector.value) {
                            // 直接指定 + システムフォント選択の場合
                            textElement.style.fontFamily = `"${systemFontSelector.value}", sans-serif`;
                            console.log('システムフォント設定:', lang_line[i-1], systemFontSelector.value);
                        } else if (fontSelector.value !== 'direct' && fontSelector.value !== '') {
                            // プリセットフォント選択の場合
                            var fontValue = fontSelector.value.replace(/\\\\/g, '');  // バックスラッシュを除去
                            textElement.style.fontFamily = `"${fontValue}", sans-serif`;
                            console.log('プリセットフォント設定:', lang_line[i-1], fontValue);
                        }
                    }
                }
            }
            
            // 背景色を全てのimb要素に適用
            changeTextColor('imb', bgcolor, 1);
            
            // 改行設定
            var whiteSpace = document.getElementById('whiteSpace').value;
            if (textTable && whiteSpace) {
                textTable.style.whiteSpace = whiteSpace;
            }
            
            
            // システムフォントプルダウンの状態を更新
            selectFont();
            
            return true;
        } catch (error) {
            console.error('設定適用中にエラー:', error);
            return false;
        }
    }

</script>

<!-- # ファイル生成用のスクリプト ############################## -->
<script>  
    function generateFile(content, fileName) {
      const blob = new Blob([content], { type: 'text/plain' });
      const link = document.createElement('a');
      link.href = window.URL.createObjectURL(blob);
      link.download = fileName;
      
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  
    function generateBatFile(os) {
    //   let url = document.getElementById('url').value.trim();
        let url = currentURL;
      // URLデコードを行う
      url = decodeURIComponent(url);
  
      if (url === '') {
        alert('URLがありません．エラーです．');
        return;
      }
      
      let content, filename;
  
      if (os === 'win') {
        content = `@echo off\r\nset "USERPROFILE=%LOCALAPPDATA%\\Google\\Chrome\\User Data\\user_jimaku_001"\r\nstart chrome.exe --disable-features=CalculateNativeWinOcclusion --user-data-dir="%USERPROFILE%" --new-window "${url}"\r\nexit /b`;
        filename = "jimakuChan_nonStop.bat";

      } else {
        content = `#!/bin/sh\n"/Applications/Google Chrome.app/Contents/MacOS/Google Chrome" --disable-features=CalculateNativeWinOcclusion --user-data-dir="Library/Application Support/Google/Chrome/user_jimaku_001"  --new-window "${url}"`;
        filename = "jimakuChan_nonStop.command";
      }
  
      generateFile(content, filename);
    }

</script>

<!-- # 設定ファイルの保存と読込 ############################## -->
<script>

    // Save all presets to a file (全プリセットをファイルに保存)
    function saveSettings() {
        const presets = localStorage.getItem('jimakuChan_presets');
        if (!presets) {
            alert('保存するプリセットが見つかりません！');
            return;
        }
        
        try {
            const presetsData = JSON.parse(presets);
            const exportData = {
                version: "2025.8.17 09:48",
                exportDate: new Date().toISOString(),
                presets: presetsData
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'jimakuChan_presets.json';
            link.click();
            URL.revokeObjectURL(link.href);
            console.log('プリセットをファイルに保存しました');
        } catch (error) {
            alert('プリセット保存エラー: ' + error.message);
            console.error('プリセット保存エラー:', error);
        }
    }

    // Load presets from a file (プリセットをファイルから読み込み)
    function loadSettings() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = e => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(readEvent) {
                try {
                    const data = JSON.parse(readEvent.target.result);
                    console.log('読み込んだファイル:', data);
                    
                    // 新形式のプリセットファイルの場合
                    if (data.presets && data.version) {
                        console.log('新形式プリセットファイルを読み込み');
                        localStorage.setItem('jimakuChan_presets', JSON.stringify(data.presets));
                        alert(`プリセットを読み込みました (ver.${data.version})`);
                        location.reload();
                    }
                    // 旧形式の設定ファイルの場合（互換性のため）
                    else if (data && typeof data === 'object' && !data.presets) {
                        console.log('旧形式設定ファイルを読み込み - プリセットに変換');
                        const convertedPreset = {
                            default: {
                                name: '読み込んだ設定',
                                settings: data,
                                lastModified: new Date().toISOString(),
                                importedFrom: 'legacy_file'
                            }
                        };
                        localStorage.setItem('jimakuChan_presets', JSON.stringify(convertedPreset));
                        alert('旧形式の設定ファイルをプリセットに変換して読み込みました');
                        location.reload();
                    }
                    else {
                        alert('不正なファイル形式です');
                    }
                } catch (error) {
                    alert('ファイル読み込みエラー: ' + error.message);
                    console.error('ファイル読み込みエラー:', error);
                }
            };
            reader.readAsText(file);
        };
        input.click();
    }

</script>

<!-- # 設定プリセット機能　############################ -->
<script>
    // プリセットの定義（可愛い配色で改善）
    const defaultPresets = {
        default: {
            name: "📋 選択してください",
            settings: {
                gas_key: "",
                textAlign: "center",
                v_align: "bottom",
                whiteSpace: "",
                bgcolor: "#00ff00",
                recog: "ja",
                size1: "25",
                weight1: "900",
                color1: "#ffffff",
                st_color1: "#000000",
                st_width1: "6",
                trans: "en",
                size2: "25",
                weight2: "900",
                color2: "#ffffff",
                st_color2: "#000000",
                st_width2: "6",
                trans2: "none",
                size3: "25",
                weight3: "900",
                color3: "#ffffff",
                st_color3: "#000000",
                st_width3: "6",
                trans3: "none",
                size4: "25",
                weight4: "900",
                color4: "#ffffff",
                st_color4: "#000000",
                st_width4: "6",
                timer: "7000",
                short_pause: "750",
                bouyomi: false,
                anti_sexual: false,
                speech_text_font_selector: "M PLUS Rounded\\ 1c",
                trans_text_font_selector: "M PLUS Rounded\\ 1c",
                trans_text2_font_selector: "M PLUS Rounded\\ 1c",
                trans_text3_font_selector: "M PLUS Rounded\\ 1c",
                speech_text_system_font: "",
                trans_text_system_font: "",
                trans_text2_system_font: "",
                trans_text3_system_font: ""
            }
        },
        gaming: {
            name: "🎮 ゲーム配信用",
            settings: {
                gas_key: "",
                textAlign: "center",
                v_align: "bottom",
                whiteSpace: "",
                bgcolor: "#00ff00",
                recog: "ja",
                size1: "28",
                weight1: "900",
                color1: "#ffffff",
                st_color1: "#ff6b9d",
                st_width1: "6",
                trans: "en",
                size2: "24",
                weight2: "900",
                color2: "#ffeb3b",
                st_color2: "#7b1fa2",
                st_width2: "4",
                trans2: "none",
                size3: "25",
                weight3: "900",
                color3: "#ffffff",
                st_color3: "#000000",
                st_width3: "6",
                trans3: "none",
                size4: "25",
                weight4: "900",
                color4: "#ffffff",
                st_color4: "#000000",
                st_width4: "6",
                timer: "5000",
                short_pause: "1000",
                bouyomi: false,
                anti_sexual: false,
                speech_text_font_selector: "M PLUS Rounded\\ 1c",
                trans_text_font_selector: "M PLUS Rounded\\ 1c",
                trans_text2_font_selector: "M PLUS Rounded\\ 1c",
                trans_text3_font_selector: "M PLUS Rounded\\ 1c",
                speech_text_system_font: "",
                trans_text_system_font: "",
                trans_text2_system_font: "",
                trans_text3_system_font: ""
            }
        },
        meeting: {
            name: "💼 会議・打ち合わせ用",
            settings: {
                gas_key: "",
                textAlign: "left",
                v_align: "top",
                whiteSpace: "",
                bgcolor: "#00ff00",
                recog: "ja",
                size1: "22",
                weight1: "500",
                color1: "#2e3440",
                st_color1: "#eceff4",
                st_width1: "3",
                trans: "en",
                size2: "20",
                weight2: "500",
                color2: "#5e81ac",
                st_color2: "#eceff4",
                st_width2: "2",
                trans2: "none",
                size3: "25",
                weight3: "900",
                color3: "#ffffff",
                st_color3: "#000000",
                st_width3: "6",
                trans3: "none",
                size4: "25",
                weight4: "900",
                color4: "#ffffff",
                st_color4: "#000000",
                st_width4: "6",
                timer: "10000",
                short_pause: "750",
                bouyomi: false,
                anti_sexual: false,
                speech_text_font_selector: "M PLUS Rounded\\ 1c",
                trans_text_font_selector: "M PLUS Rounded\\ 1c",
                trans_text2_font_selector: "M PLUS Rounded\\ 1c",
                trans_text3_font_selector: "M PLUS Rounded\\ 1c",
                speech_text_system_font: "",
                trans_text_system_font: "",
                trans_text2_system_font: "",
                trans_text3_system_font: ""
            }
        },
        language_learning: {
            name: "📚 語学学習用",
            settings: {
                gas_key: "",
                textAlign: "center",
                v_align: "center",
                whiteSpace: "",
                bgcolor: "#00ff00",
                recog: "ja",
                size1: "26",
                weight1: "600",
                color1: "#2d3748",
                st_color1: "#bee3f8",
                st_width1: "4",
                trans: "en",
                size2: "22",
                weight2: "600",
                color2: "#d53f8c",
                st_color2: "#fed7e2",
                st_width2: "3",
                trans2: "none",
                size3: "22",
                weight3: "600",
                color3: "#3182ce",
                st_color3: "#bee3f8",
                st_width3: "3",
                trans3: "none",
                size4: "25",
                weight4: "900",
                color4: "#ffffff",
                st_color4: "#000000",
                st_width4: "6",
                timer: "15000",
                short_pause: "500",
                bouyomi: false,
                anti_sexual: false,
                speech_text_font_selector: "M PLUS Rounded\\ 1c",
                trans_text_font_selector: "M PLUS Rounded\\ 1c",
                trans_text2_font_selector: "M PLUS Rounded\\ 1c",
                trans_text3_font_selector: "M PLUS Rounded\\ 1c",
                speech_text_system_font: "",
                trans_text_system_font: "",
                trans_text2_system_font: "",
                trans_text3_system_font: ""
            }
        },
        accessibility: {
            name: "♿ アクセシビリティ重視",
            settings: {
                gas_key: "",
                textAlign: "center",
                v_align: "bottom",
                whiteSpace: "",
                bgcolor: "#00ff00",
                recog: "ja",
                size1: "32",
                weight1: "900",
                color1: "#ffffff",
                st_color1: "#000000",
                st_width1: "8",
                trans: "en",
                size2: "25",
                weight2: "900",
                color2: "#ffffff",
                st_color2: "#000000",
                st_width2: "6",
                trans2: "none",
                size3: "25",
                weight3: "900",
                color3: "#ffffff",
                st_color3: "#000000",
                st_width3: "6",
                trans3: "none",
                size4: "25",
                weight4: "900",
                color4: "#ffffff",
                st_color4: "#000000",
                st_width4: "6",
                timer: "7000",
                short_pause: "1500",
                bouyomi: false,
                anti_sexual: false,
                speech_text_font_selector: "M PLUS Rounded\\ 1c",
                trans_text_font_selector: "M PLUS Rounded\\ 1c",
                trans_text2_font_selector: "M PLUS Rounded\\ 1c",
                trans_text3_font_selector: "M PLUS Rounded\\ 1c",
                speech_text_system_font: "",
                trans_text_system_font: "",
                trans_text2_system_font: "",
                trans_text3_system_font: ""
            }
        },
        cute_streaming: {
            name: "🌸 かわいい配信用",
            settings: {
                gas_key: "",
                textAlign: "center",
                v_align: "bottom",
                whiteSpace: "",
                bgcolor: "#00ff00",
                recog: "ja",
                size1: "30",
                weight1: "700",
                color1: "#ffffff",
                st_color1: "#ff69b4",
                st_width1: "5",
                trans: "en",
                size2: "26",
                weight2: "700",
                color2: "#ff1493",
                st_color2: "#ffb6c1",
                st_width2: "4",
                trans2: "none",
                size3: "25",
                weight3: "900",
                color3: "#ffffff",
                st_color3: "#000000",
                st_width3: "6",
                trans3: "none",
                size4: "25",
                weight4: "900",
                color4: "#ffffff",
                st_color4: "#000000",
                st_width4: "6",
                timer: "6000",
                short_pause: "800",
                bouyomi: false,
                anti_sexual: false,
                speech_text_font_selector: "M PLUS Rounded\\ 1c",
                trans_text_font_selector: "M PLUS Rounded\\ 1c",
                trans_text2_font_selector: "M PLUS Rounded\\ 1c",
                trans_text3_font_selector: "M PLUS Rounded\\ 1c",
                speech_text_system_font: "",
                trans_text_system_font: "",
                trans_text2_system_font: "",
                trans_text3_system_font: ""
            }
        },
        dark_theme: {
            name: "🌙 ダークテーマ",
            settings: {
                gas_key: "",
                textAlign: "center",
                v_align: "bottom",
                whiteSpace: "",
                bgcolor: "#00ff00",
                recog: "ja",
                size1: "27",
                weight1: "600",
                color1: "#e2e8f0",
                st_color1: "#4a5568",
                st_width1: "4",
                trans: "en",
                size2: "23",
                weight2: "600",
                color2: "#81e6d9",
                st_color2: "#2d3748",
                st_width2: "3",
                trans2: "none",
                size3: "25",
                weight3: "900",
                color3: "#ffffff",
                st_color3: "#000000",
                st_width3: "6",
                trans3: "none",
                size4: "25",
                weight4: "900",
                color4: "#ffffff",
                st_color4: "#000000",
                st_width4: "6",
                timer: "7000",
                short_pause: "900",
                bouyomi: false,
                anti_sexual: false,
                speech_text_font_selector: "M PLUS Rounded\\ 1c",
                trans_text_font_selector: "M PLUS Rounded\\ 1c",
                trans_text2_font_selector: "M PLUS Rounded\\ 1c",
                trans_text3_font_selector: "M PLUS Rounded\\ 1c",
                speech_text_system_font: "",
                trans_text_system_font: "",
                trans_text2_system_font: "",
                trans_text3_system_font: ""
            }
        },
        rainbow: {
            name: "🌈 レインボー",
            settings: {
                gas_key: "",
                textAlign: "center",
                v_align: "bottom",
                whiteSpace: "",
                bgcolor: "#00ff00",
                recog: "ja",
                size1: "29",
                weight1: "800",
                color1: "#ffffff",
                st_color1: "#ff0080",
                st_width1: "6",
                trans: "en",
                size2: "25",
                weight2: "800",
                color2: "#00ff80",
                st_color2: "#ff8000",
                st_width2: "5",
                trans2: "none",
                size3: "25",
                weight3: "800",
                color3: "#8080ff",
                st_color3: "#ff0080",
                st_width3: "5",
                trans3: "none",
                size4: "25",
                weight4: "900",
                color4: "#ffffff",
                st_color4: "#000000",
                st_width4: "6",
                timer: "5500",
                short_pause: "750",
                bouyomi: false,
                anti_sexual: false,
                speech_text_font_selector: "M PLUS Rounded\\ 1c",
                trans_text_font_selector: "M PLUS Rounded\\ 1c",
                trans_text2_font_selector: "M PLUS Rounded\\ 1c",
                trans_text3_font_selector: "M PLUS Rounded\\ 1c",
                speech_text_system_font: "",
                trans_text_system_font: "",
                trans_text2_system_font: "",
                trans_text3_system_font: ""
            }
        },
        custom1: {
            name: "🔧 カスタム１",
            settings: {
                gas_key: "",
                textAlign: "center",
                v_align: "bottom",
                whiteSpace: "",
                bgcolor: "#00ff00",
                recog: "ja",
                size1: "25",
                weight1: "900",
                color1: "#ffffff",
                st_color1: "#000000",
                st_width1: "6",
                trans: "en",
                size2: "25",
                weight2: "900",
                color2: "#ffffff",
                st_color2: "#000000",
                st_width2: "6",
                trans2: "none",
                size3: "25",
                weight3: "900",
                color3: "#ffffff",
                st_color3: "#000000",
                st_width3: "6",
                trans3: "none",
                size4: "25",
                weight4: "900",
                color4: "#ffffff",
                st_color4: "#000000",
                st_width4: "6",
                timer: "7000",
                short_pause: "750",
                bouyomi: false,
                anti_sexual: false,
                speech_text_font_selector: "M PLUS Rounded\\ 1c",
                trans_text_font_selector: "M PLUS Rounded\\ 1c",
                trans_text2_font_selector: "M PLUS Rounded\\ 1c",
                trans_text3_font_selector: "M PLUS Rounded\\ 1c",
                speech_text_system_font: "",
                trans_text_system_font: "",
                trans_text2_system_font: "",
                trans_text3_system_font: ""
            }
        },
        custom2: {
            name: "🔧 カスタム２",
            settings: {
                gas_key: "",
                textAlign: "center",
                v_align: "bottom",
                whiteSpace: "",
                bgcolor: "#00ff00",
                recog: "ja",
                size1: "25",
                weight1: "900",
                color1: "#ffffff",
                st_color1: "#000000",
                st_width1: "6",
                trans: "en",
                size2: "25",
                weight2: "900",
                color2: "#ffffff",
                st_color2: "#000000",
                st_width2: "6",
                trans2: "none",
                size3: "25",
                weight3: "900",
                color3: "#ffffff",
                st_color3: "#000000",
                st_width3: "6",
                trans3: "none",
                size4: "25",
                weight4: "900",
                color4: "#ffffff",
                st_color4: "#000000",
                st_width4: "6",
                timer: "7000",
                short_pause: "750",
                bouyomi: false,
                anti_sexual: false,
                speech_text_font_selector: "M PLUS Rounded\\ 1c",
                trans_text_font_selector: "M PLUS Rounded\\ 1c",
                trans_text2_font_selector: "M PLUS Rounded\\ 1c",
                trans_text3_font_selector: "M PLUS Rounded\\ 1c",
                speech_text_system_font: "",
                trans_text_system_font: "",
                trans_text2_system_font: "",
                trans_text3_system_font: ""
            }
        },
        custom3: {
            name: "🔧 カスタム３",
            settings: {
                gas_key: "",
                textAlign: "center",
                v_align: "bottom",
                whiteSpace: "",
                bgcolor: "#00ff00",
                recog: "ja",
                size1: "25",
                weight1: "900",
                color1: "#ffffff",
                st_color1: "#000000",
                st_width1: "6",
                trans: "en",
                size2: "25",
                weight2: "900",
                color2: "#ffffff",
                st_color2: "#000000",
                st_width2: "6",
                trans2: "none",
                size3: "25",
                weight3: "900",
                color3: "#ffffff",
                st_color3: "#000000",
                st_width3: "6",
                trans3: "none",
                size4: "25",
                weight4: "900",
                color4: "#ffffff",
                st_color4: "#000000",
                st_width4: "6",
                timer: "7000",
                short_pause: "750",
                bouyomi: false,
                anti_sexual: false,
                speech_text_font_selector: "M PLUS Rounded\\ 1c",
                trans_text_font_selector: "M PLUS Rounded\\ 1c",
                trans_text2_font_selector: "M PLUS Rounded\\ 1c",
                trans_text3_font_selector: "M PLUS Rounded\\ 1c",
                speech_text_system_font: "",
                trans_text_system_font: "",
                trans_text2_system_font: "",
                trans_text3_system_font: ""
            }
        }
    };

    // 現在選択中のプリセットを保存（初期化関数内で設定）
    let currentPreset = 'default';
    
    // プリセット読み込み中フラグ（自動保存を一時停止するため）
    let isLoadingPreset = false;
    
    // プリセットを読み込む
    function loadPreset() {
        const presetSelect = document.getElementById('presetSelect');
        const selectedPreset = presetSelect.value;
        
        if (!selectedPreset) return;
        
        console.log('プリセット切り替え開始:', selectedPreset);
        
        // プリセット読み込み中フラグを設定（自動保存を停止）
        isLoadingPreset = true;
        
        // 「選択してください」が選ばれた場合は設定を適用してすぐに完了
        if (selectedPreset === 'default') {
            console.log('「選択してください」プリセット処理開始');
            
            // 設定状態を保存
            currentPreset = selectedPreset;
            try {
                localStorage.setItem('selectedPreset', selectedPreset);
                console.log('プリセット選択状態を保存:', selectedPreset);
            } catch (error) {
                console.error('localStorage保存エラー:', error);
            }
            
            // まず保存済みの設定があるかチェック
            const savedPresets = JSON.parse(localStorage.jimakuChan_presets || '{}');
            let settingsToApply;
            
            if (savedPresets[selectedPreset] && savedPresets[selectedPreset].settings) {
                settingsToApply = savedPresets[selectedPreset].settings;
                console.log('保存済み「選択してください」プリセットを使用');
                console.log('保存済み設定の一部:', {
                    bgcolor: settingsToApply.bgcolor,
                    trans: settingsToApply.trans,
                    speech_text_font_selector: settingsToApply.speech_text_font_selector
                });
            } else {
                settingsToApply = defaultPresets.default.settings;
                console.log('デフォルト「選択してください」プリセットを使用（保存済み設定なし）');
            }
            
            // 設定を適用
            for (const [key, value] of Object.entries(settingsToApply)) {
                const element = document.getElementById(key);
                if (element) {
                    if (element.type === 'checkbox') {
                        element.checked = value;
                    } else {
                        element.value = value;
                    }
                }
            }
            
            // 翻訳方法の復元
            const chromeRadio = document.getElementById('translationMethodChrome');
            const gasRadio = document.getElementById('translationMethodGas');
            const notice = document.getElementById('chromeTranslationNotice');
            
            if (chromeRadio && gasRadio && notice) {
                let methodToApply = 'chrome'; // デフォルト
                
                if (settingsToApply.translation_method) {
                    // 保存済み設定に翻訳方法がある場合
                    methodToApply = settingsToApply.translation_method;
                    console.log('翻訳方法を保存済み設定から復元:', methodToApply);
                } else {
                    // 設定がない場合はlocalStorageから取得
                    methodToApply = loadTranslationMethodFromStorage();
                    console.log('翻訳方法をlocalStorageから復元:', methodToApply);
                }
                
                // ラジオボタンと注意書きを設定
                if (methodToApply === 'chrome') {
                    chromeRadio.checked = true;
                    gasRadio.checked = false;
                    notice.style.display = 'block';
                } else {
                    chromeRadio.checked = false;
                    gasRadio.checked = true;
                    notice.style.display = 'none';
                }
                
                // 設定をlocalStorageにも保存（同期のため）
                saveTranslationMethodToStorage(methodToApply);
            }
            
            // 設定を反映
            updateOptionValues(false);
            setTimeout(() => {
                applyAllSettings();
                selectFont(); // フォント状態も更新
                initializeSystemFontFields(); // PC内フォントと直接入力フィールドの状態を復元
                updateVisualSettings(); // スライドバー数値表示を更新
                applyFrameHeight(); // frame_height（設定画面表示/非表示）を適用
            }, 100);
            
            // フラグをリセット
            isLoadingPreset = false;
            updatePageTitle();
            
            // 強制的に自動保存を実行
            console.log('「選択してください」プリセット - 強制自動保存実行');
            setTimeout(saveCurrentPreset, 200);
            
            console.log('「選択してください」プリセット処理完了');
            return;
        }
        
        // 選択状態を保存
        currentPreset = selectedPreset;
        try {
            localStorage.setItem('selectedPreset', selectedPreset);
            console.log('プリセット選択状態を保存:', selectedPreset);
            console.log('保存確認:', localStorage.getItem('selectedPreset'));
        } catch (error) {
            console.error('localStorage保存エラー:', error);
        }
        
        let presetData = null;
        
        // まず保存されたプリセットをチェック（優先）
        const savedPresets = JSON.parse(localStorage.jimakuChan_presets || '{}');
        if (savedPresets[selectedPreset]) {
            presetData = savedPresets[selectedPreset].settings;
            console.log('保存済みプリセットデータを使用:', selectedPreset);
        } else if (defaultPresets[selectedPreset]) {
            // 保存されたデータがない場合のみデフォルトプリセットを使用
            presetData = defaultPresets[selectedPreset].settings;
            console.log('デフォルトプリセットデータを使用:', selectedPreset);
        }
        
        if (presetData) {
            console.log('プリセットデータ適用中:', Object.keys(presetData).length + '個の設定');
            
            // 設定を適用
            for (const key in presetData) {
                const element = document.getElementById(key);
                if (element) {
                    if (element.type === 'checkbox') {
                        element.checked = presetData[key];
                    } else {
                        element.value = presetData[key];
                    }
                }
            }
            
            // 翻訳方法の復元
            const chromeRadio = document.getElementById('translationMethodChrome');
            const gasRadio = document.getElementById('translationMethodGas');
            const notice = document.getElementById('chromeTranslationNotice');
            
            if (chromeRadio && gasRadio && notice) {
                let methodToApply = 'chrome'; // デフォルト
                
                if (presetData.translation_method) {
                    // プリセットに翻訳方法の設定がある場合はそれを優先
                    methodToApply = presetData.translation_method;
                    console.log('翻訳方法をプリセットから復元:', methodToApply);
                } else {
                    // プリセットに設定がない場合はlocalStorageから取得
                    methodToApply = loadTranslationMethodFromStorage();
                    console.log('翻訳方法をlocalStorageから復元:', methodToApply);
                }
                
                // ラジオボタンと注意書きを設定
                if (methodToApply === 'chrome') {
                    chromeRadio.checked = true;
                    gasRadio.checked = false;
                    notice.style.display = 'block';
                } else {
                    chromeRadio.checked = false;
                    gasRadio.checked = true;
                    notice.style.display = 'none';
                }
                
                // 設定をlocalStorageにも保存（同期のため）
                saveTranslationMethodToStorage(methodToApply);
            }
            
            // フォント設定の特別処理
            selectFont();
            
            // 表示を更新（スライダー値表示など）
            updateVisualSettings();
            
            // frame_height（設定画面表示/非表示）を適用
            applyFrameHeight();
            
            // 強制リロードによる確実な更新
            console.log('プリセット強制更新を実行中...');
            
            var iframe = document.getElementById('asr_frame');
            
            // 設定を適用
            updateOptionValues(false);
            
            // 複数回のリロード試行で確実性を向上
            var reloadAttempts = 0;
            var maxAttempts = 3;
            
            function attemptReload() {
                reloadAttempts++;
                console.log(`リロード試行 ${reloadAttempts}/${maxAttempts}`);
                
                // iframeを強制リロード
                var currentSrc = iframe.src;
                iframe.src = 'about:blank';
                
                setTimeout(function() {
                    iframe.src = currentSrc;
                    
                    // 読み込み完了を待機
                    iframe.onload = function() {
                        console.log(`リロード完了 (${reloadAttempts}/${maxAttempts})`);
                        
                        setTimeout(function() {
                            try {
                                if (iframe.contentWindow && iframe.contentWindow.document) {
                                    console.log('DOM直接更新実行中...');
                                    var settingsApplied = applyAllSettings();
                                    
                                    if (settingsApplied || reloadAttempts >= maxAttempts) {
                                        console.log('プリセット更新完了');
                                        isLoadingPreset = false;
                                        
                                        // ページタイトルを更新
                                        updatePageTitle();
                                        
                                        // 通常のonloadハンドラーに戻す
                                        iframe.onload = function() {
                                            console.log('iframe読み込み完了');
                                            setTimeout(applyInitialSettings, 300);
                                        };
                                    } else {
                                        console.log('設定適用失敗 - 再試行中...');
                                        setTimeout(attemptReload, 500);
                                    }
                                } else {
                                    if (reloadAttempts < maxAttempts) {
                                        console.log('DOM未準備 - 再試行中...');
                                        setTimeout(attemptReload, 500);
                                    } else {
                                        console.log('最大試行回数に到達 - 終了');
                                        isLoadingPreset = false;
                                        
                                        // ページタイトルを更新
                                        updatePageTitle();
                                        
                                        // 通常のonloadハンドラーに戻す
                                        iframe.onload = function() {
                                            console.log('iframe読み込み完了');
                                            setTimeout(applyInitialSettings, 300);
                                        };
                                    }
                                }
                            } catch (error) {
                                console.error('プリセット適用エラー:', error);
                                if (reloadAttempts < maxAttempts) {
                                    setTimeout(attemptReload, 500);
                                } else {
                                    console.log('エラーにより処理終了');
                                    isLoadingPreset = false;
                                    
                                    // ページタイトルを更新
                                    updatePageTitle();
                                    
                                    // 通常のonloadハンドラーに戻す
                                    iframe.onload = function() {
                                        console.log('iframe読み込み完了');
                                        setTimeout(applyInitialSettings, 300);
                                    };
                                }
                            }
                        }, 500);
                    };
                }, 100);
            }
            
            // 初回試行を開始
            attemptReload();
            
            console.log('プリセット「' + selectedPreset + '」を読み込み完了');
        } else {
            console.error('プリセットデータが見つかりません:', selectedPreset);
            isLoadingPreset = false;
            
            // ページタイトルを更新
            updatePageTitle();
        }
    }
    
    // 現在のプリセットに設定を自動保存
    function saveCurrentPreset() {
        console.log('saveCurrentPreset呼び出し - currentPreset:', currentPreset, 'isLoadingPreset:', isLoadingPreset);
        
        if (!currentPreset || isLoadingPreset) {
            if (isLoadingPreset) console.log('プリセット読み込み中のため自動保存をスキップ');
            if (!currentPreset) console.log('現在のプリセットが未設定のため自動保存をスキップ');
            return;
        }
        
        console.log('自動保存開始 - プリセット:', currentPreset);
        
        // 現在の設定を取得
        const currentSettings = {};
        for (const p of config_values) {
            // translation_methodは特別処理なのでスキップ
            if (p === 'translation_method') {
                continue;
            }
            const element = document.getElementById(p);
            if (element) {
                if (element.type === 'checkbox') {
                    currentSettings[p] = element.checked;
                } else {
                    currentSettings[p] = element.value;
                }
            }
        }
        
        // チェックボックス設定も含める
        currentSettings.bouyomi = document.getElementById('bouyomi').checked;
        currentSettings.anti_sexual = document.getElementById('anti_sexual').checked;
        currentSettings.translation_method = getTranslationMethod();
        
        // プリセットを保存
        const savedPresets = JSON.parse(localStorage.jimakuChan_presets || '{}');
        savedPresets[currentPreset] = {
            name: defaultPresets[currentPreset] ? defaultPresets[currentPreset].name : currentPreset,
            settings: currentSettings,
            lastModified: new Date().toISOString()
        };
        
        localStorage.jimakuChan_presets = JSON.stringify(savedPresets);
        console.log('プリセット「' + currentPreset + '」に自動保存しました');
        console.log('保存された設定の一部:', {
            bgcolor: currentSettings.bgcolor,
            size1: currentSettings.size1,
            color1: currentSettings.color1,
            recog: currentSettings.recog,
            trans: currentSettings.trans,
            speech_text_font_selector: currentSettings.speech_text_font_selector
        });
        
        // 保存確認のため、localStorageから読み直し
        const verifyPresets = JSON.parse(localStorage.jimakuChan_presets || '{}');
        if (verifyPresets[currentPreset]) {
            console.log('保存確認OK - プリセット「' + currentPreset + '」が存在します');
        } else {
            console.error('保存確認NG - プリセット「' + currentPreset + '」が見つかりません');
        }
    }
    
    // デバッグ用：保存されたプリセットを確認
    function debugPresets() {
        const savedPresets = JSON.parse(localStorage.jimakuChan_presets || '{}');
        console.log('=== 保存されたプリセット一覧 ===');
        for (const [key, value] of Object.entries(savedPresets)) {
            console.log(`${key}:`, {
                name: value.name,
                lastModified: value.lastModified,
                settingsCount: Object.keys(value.settings).length,
                sampleSettings: {
                    bgcolor: value.settings.bgcolor,
                    size1: value.settings.size1,
                    recog: value.settings.recog,
                    trans: value.settings.trans
                }
            });
        }
        console.log('=== 現在のプリセット ===', currentPreset);
    }
    
    // グローバルに公開（ブラウザコンソールから実行可能）
    window.debugPresets = debugPresets;
    
    // プリセット選択状態をデバッグする関数
    function debugPresetSelection() {
        console.log('=== プリセット選択状態デバッグ ===');
        console.log('currentPreset変数:', currentPreset);
        console.log('localStorage.selectedPreset:', localStorage.getItem('selectedPreset'));
        
        const presetSelect = document.getElementById('presetSelect');
        if (presetSelect) {
            console.log('プルダウンの現在値:', presetSelect.value);
            console.log('プルダウンの選択されたオプション:', presetSelect.options[presetSelect.selectedIndex]?.text);
        } else {
            console.log('プルダウンが見つかりません');
        }
    }
    
    window.debugPresetSelection = debugPresetSelection;
    
    // 既存ユーザー設定の自動移行関数
    function migrateExistingUserSettings() {
        console.log('=== 既存ユーザー設定移行チェック開始 ===');
        
        // 旧設定の存在チェック（最初に確認）
        const oldConfig = localStorage.getItem('jimakuChan_config');
        const migrationFlag = localStorage.getItem('jimakuChan_migrated');
        
        console.log('移行状況確認:', {
            oldConfig: !!oldConfig,
            migrationFlag: migrationFlag,
            oldConfigLength: oldConfig ? oldConfig.length : 0
        });
        
        // 旧設定がない場合の処理
        if (!oldConfig) {
            console.log('旧設定なし - 移行不要');
            if (migrationFlag !== 'true') {
                localStorage.setItem('jimakuChan_migrated', 'true');
                console.log('新規ユーザーとして移行フラグ設定');
            }
            return;
        }
        
        // 移行済みフラグがあるが旧設定も残っている場合（移行失敗の可能性）
        if (migrationFlag === 'true' && oldConfig) {
            console.warn('⚠️ 移行済みフラグがあるが旧設定が残存 - 再移行を実行');
            console.log('この状況は移行失敗の可能性があります');
        }
        
        try {
            const oldSettings = JSON.parse(oldConfig);
            console.log('旧設定を発見:', Object.keys(oldSettings).length + '項目');
            console.log('旧設定サンプル:', {
                bgcolor: oldSettings.bgcolor,
                size1: oldSettings.size1,
                recog: oldSettings.recog,
                trans: oldSettings.trans
            });
            
            // 「選択してください」プリセットの既存チェック
            const savedPresets = JSON.parse(localStorage.getItem('jimakuChan_presets') || '{}');
            
            if (savedPresets['default'] && savedPresets['default'].settings) {
                console.log('「選択してください」プリセット既存 - 旧設定移行をスキップ');
                // 移行済みフラグを設定
                localStorage.setItem('jimakuChan_migrated', 'true');
                return;
            }
            
            // 旧設定を「選択してください」プリセットに移行
            console.log('旧設定を「選択してください」プリセットに移行開始');
            
            // デフォルトプリセットの設定項目に合わせて移行
            const migratedSettings = {};
            
            // 設定項目のマッピング（config_valuesと完全一致）
            const settingKeys = [
                'gas_key', 'textAlign', 'v_align', 'whiteSpace', 'bgcolor', 'frame_height',
                'recog', 'size1', 'weight1', 'color1', 'st_color1', 'st_width1',
                'trans', 'size2', 'weight2', 'color2', 'st_color2', 'st_width2',
                'trans2', 'size3', 'weight3', 'color3', 'st_color3', 'st_width3',
                'trans3', 'size4', 'weight4', 'color4', 'st_color4', 'st_width4',
                'timer', 'short_pause', 'bouyomi', 'anti_sexual',
                'speech_text_font_selector', 'trans_text_font_selector', 
                'trans_text2_font_selector', 'trans_text3_font_selector',
                'speech_text_system_font', 'trans_text_system_font',
                'trans_text2_system_font', 'trans_text3_system_font'
            ];
            
            // 旧設定から新設定にコピー（詳細ログ付き）
            console.log('=== 設定項目別移行状況 ===');
            let migratedCount = 0;
            let skippedCount = 0;
            
            settingKeys.forEach(key => {
                if (oldSettings.hasOwnProperty(key)) {
                    migratedSettings[key] = oldSettings[key];
                    console.log(`✅ ${key}: "${oldSettings[key]}" -> 移行`);
                    migratedCount++;
                } else {
                    console.log(`⚠️ ${key}: 旧設定に存在しない`);
                    skippedCount++;
                }
            });
            
            console.log(`移行完了: ${migratedCount}項目, スキップ: ${skippedCount}項目`);
            
            // フォント設定の移行（旧システム対応）
            if (oldSettings.speech_text_font && !migratedSettings.speech_text_font_selector) {
                migratedSettings.speech_text_font_selector = oldSettings.speech_text_font;
            }
            if (oldSettings.trans_text_font && !migratedSettings.trans_text_font_selector) {
                migratedSettings.trans_text_font_selector = oldSettings.trans_text_font;
            }
            if (oldSettings.trans_text2_font && !migratedSettings.trans_text2_font_selector) {
                migratedSettings.trans_text2_font_selector = oldSettings.trans_text2_font;
            }
            if (oldSettings.trans_text3_font && !migratedSettings.trans_text3_font_selector) {
                migratedSettings.trans_text3_font_selector = oldSettings.trans_text3_font;
            }
            
            // デフォルト値で不足項目を補完
            console.log('=== デフォルト値補完処理 ===');
            const defaultSettings = defaultPresets['default']?.settings || {};
            
            // 基本的なデフォルト値を設定
            const basicDefaults = {
                textAlign: 'center',
                v_align: 'top',
                bgcolor: '#00ff00',
                whiteSpace: '',
                recog: 'ja',
                size1: '25', weight1: '900', color1: '#ffffff', st_color1: '#000000', st_width1: '6',
                trans: 'none',
                size2: '25', weight2: '900', color2: '#ffffff', st_color2: '#000000', st_width2: '6',
                trans2: 'none',
                size3: '25', weight3: '900', color3: '#ffffff', st_color3: '#000000', st_width3: '6',
                trans3: 'none',
                size4: '25', weight4: '900', color4: '#ffffff', st_color4: '#000000', st_width4: '6',
                timer: '7000',
                short_pause: '750',
                bouyomi: false,
                anti_sexual: false,
                speech_text_font_selector: 'M PLUS Rounded\\ 1c',
                trans_text_font_selector: 'M PLUS Rounded\\ 1c',
                trans_text2_font_selector: 'M PLUS Rounded\\ 1c',
                trans_text3_font_selector: 'M PLUS Rounded\\ 1c',
                speech_text_system_font: '',
                trans_text_system_font: '',
                trans_text2_system_font: '',
                trans_text3_system_font: '',
                frame_height: '30%',
                gas_key: ''
            };
            
            let defaultCount = 0;
            settingKeys.forEach(key => {
                if (!migratedSettings.hasOwnProperty(key)) {
                    // まずdefaultPresetsから試す
                    if (defaultSettings.hasOwnProperty(key)) {
                        migratedSettings[key] = defaultSettings[key];
                        console.log(`📝 ${key}: デフォルトプリセットから補完 -> "${defaultSettings[key]}"`);
                    }
                    // 次にbasicDefaultsから試す
                    else if (basicDefaults.hasOwnProperty(key)) {
                        migratedSettings[key] = basicDefaults[key];
                        console.log(`📝 ${key}: 基本デフォルト値で補完 -> "${basicDefaults[key]}"`);
                    }
                    else {
                        console.log(`❌ ${key}: デフォルト値なし`);
                    }
                    defaultCount++;
                }
            });
            
            console.log(`デフォルト値補完: ${defaultCount}項目`);
            
            // 「選択してください」プリセットとして保存
            savedPresets['default'] = {
                name: '選択してください',
                settings: migratedSettings,
                lastModified: new Date().toISOString(),
                migratedFrom: 'jimakuChan_config'
            };
            
            localStorage.setItem('jimakuChan_presets', JSON.stringify(savedPresets));
            
            // 移行後検証：実際に保存されたか確認
            console.log('=== 移行後検証 ===');
            const verifyPresets = JSON.parse(localStorage.getItem('jimakuChan_presets') || '{}');
            if (verifyPresets.default && verifyPresets.default.settings) {
                console.log('✅ 「選択してください」プリセット保存確認OK');
                console.log('保存された設定項目数:', Object.keys(verifyPresets.default.settings).length);
                
                // 重要な設定項目を個別確認
                const verifySettings = verifyPresets.default.settings;
                const criticalKeys = ['bgcolor', 'size1', 'recog', 'gas_key', 'timer'];
                console.log('=== 重要設定項目確認 ===');
                criticalKeys.forEach(key => {
                    console.log(`${key}: "${verifySettings[key] || 'undefined'}"`);
                });
                
            } else {
                console.error('❌ 「選択してください」プリセット保存失敗');
            }
            
            console.log('✅ 設定移行完了');
            console.log('移行された設定項目数:', Object.keys(migratedSettings).length);
            
            // 移行成功時のみフラグを設定
            localStorage.setItem('jimakuChan_migrated', 'true');
            
            // 旧設定をバックアップ用にリネーム（削除はしない）
            localStorage.setItem('jimakuChan_config_backup', oldConfig);
            console.log('旧設定をバックアップとして保存: jimakuChan_config_backup');
            
            // 移行完了後、旧設定を削除（バックアップは保持）
            localStorage.removeItem('jimakuChan_config');
            console.log('✅ 旧設定(jimakuChan_config)を削除（移行完了）');
            console.log('✅ 全設定はjimakuChan_presetsで管理されるようになりました');
            
        } catch (error) {
            console.error('❌ 設定移行エラー:', error);
            console.error('移行に失敗しました。旧設定とフラグは保持されます');
            // エラー時は移行済みフラグを設定しない（再試行可能にする）
            // localStorage.setItem('jimakuChan_migrated', 'true'); // この行を削除
        }
    }
    
    // デバッグ用：移行状況確認関数
    function debugMigrationStatus() {
        console.log('=== 移行状況デバッグ ===');
        const oldConfig = localStorage.getItem('jimakuChan_config');
        const migrationFlag = localStorage.getItem('jimakuChan_migrated');
        const backup = localStorage.getItem('jimakuChan_config_backup');
        const presets = localStorage.getItem('jimakuChan_presets');
        
        console.log('旧設定(jimakuChan_config):', !!oldConfig, oldConfig ? oldConfig.length + '文字' : 'なし');
        console.log('移行フラグ(jimakuChan_migrated):', migrationFlag);
        console.log('バックアップ(jimakuChan_config_backup):', !!backup);
        console.log('プリセット(jimakuChan_presets):', !!presets);
        
        if (presets) {
            const presetsData = JSON.parse(presets);
            console.log('「選択してください」プリセット:', !!presetsData.default);
            if (presetsData.default) {
                console.log('移行元情報:', presetsData.default.migratedFrom || 'なし');
                console.log('設定項目数:', Object.keys(presetsData.default.settings || {}).length);
            }
        }
        
        return {
            hasOldConfig: !!oldConfig,
            migrationFlag: migrationFlag,
            hasBackup: !!backup,
            hasPresets: !!presets
        };
    }
    
    // グローバルからアクセス可能にする
    window.debugMigrationStatus = debugMigrationStatus;
    
    // 強制再移行関数（トラブルシューティング用）
    function forceMigration() {
        console.log('=== 強制再移行実行 ===');
        localStorage.removeItem('jimakuChan_migrated');
        console.log('移行フラグを削除しました');
        console.log('注意：この操作により、旧設定(jimakuChan_config)が存在する場合、');
        console.log('「選択してください」プリセットに移行され、旧設定は削除されます');
        migrateExistingUserSettings();
        
        // 移行後、ページを再読み込みして新しい設定を反映
        setTimeout(() => {
            console.log('移行完了後、ページを再読み込みします...');
            location.reload();
        }, 1000);
    }
    
    window.forceMigration = forceMigration;
    
    // frame_height（設定画面表示/非表示）を適用する関数
    function applyFrameHeight() {
        const frameHeightElement = document.getElementById('frame_height');
        const iframe = document.getElementById('asr_frame');
        const body = document.body;
        
        if (frameHeightElement && iframe) {
            const frameHeight = frameHeightElement.value || '30%';
            iframe.style.height = frameHeight;
            
            console.log('frame_height適用:', frameHeight);
            
            if (frameHeight === '100%') {
                body.style.overflow = 'hidden';  // ページスクロールを禁止する
            } else {
                body.style.overflow = 'auto';  // ページスクロールを有効にする
            }
        }
    }
    
    // プリセット初期化（ページ読み込み時に実行）
    function initializePresets() {
        console.log('=== プリセット初期化開始 ===');
        const presetSelect = document.getElementById('presetSelect');
        
        if (!presetSelect) {
            console.error('プリセットセレクトボックスが見つかりません');
            return;
        }
        
        // 既存ユーザー設定の自動移行処理
        migrateExistingUserSettings();
        
        // localStorageから保存されたプリセット選択状態を復元
        const savedSelectedPreset = localStorage.getItem('selectedPreset');
        console.log('保存されたプリセット選択状態:', savedSelectedPreset);
        
        if (savedSelectedPreset) {
            currentPreset = savedSelectedPreset;
        } else {
            currentPreset = 'default'; // デフォルト値
        }
        
        console.log('復元されたcurrentPreset:', currentPreset);
        
        // プルダウンメニューに値を設定
        presetSelect.value = currentPreset;
        
        // プルダウンの値が正しく設定されたか確認
        console.log('プルダウン設定後の値:', presetSelect.value);
        
        // 値が正しく設定されていない場合の対処
        if (presetSelect.value !== currentPreset) {
            console.warn('プルダウン設定に失敗、手動で設定:', currentPreset);
            // オプションが存在するか確認
            const options = Array.from(presetSelect.options);
            const targetOption = options.find(option => option.value === currentPreset);
            if (targetOption) {
                targetOption.selected = true;
                console.log('手動設定完了');
            } else {
                console.error('指定されたプリセットが見つかりません:', currentPreset);
                currentPreset = 'default';
                presetSelect.value = currentPreset;
            }
        }
        
        // 「選択してください」の場合は事前に保存済み設定を復元
        if (currentPreset === 'default') {
            console.log('「選択してください」の初期化 - 保存済み設定をチェック');
            const savedPresets = JSON.parse(localStorage.jimakuChan_presets || '{}');
            
            if (savedPresets['default'] && savedPresets['default'].settings) {
                console.log('保存済み「選択してください」設定を事前復元');
                const savedSettings = savedPresets['default'].settings;
                
                // 設定をUIに事前適用
                for (const [key, value] of Object.entries(savedSettings)) {
                    const element = document.getElementById(key);
                    if (element) {
                        if (element.type === 'checkbox') {
                            element.checked = value;
                        } else {
                            element.value = value;
                        }
                    }
                }
            }
        }
        
        // 少し遅延してプリセットを適用（DOM構築完了を待つ）
        setTimeout(function() {
            console.log('initializePresets内でloadPreset実行');
            loadPreset();
        }, 50);
    }
    
    // 表示設定を更新（スライダー数値表示）
    function updateVisualSettings() {
        console.log('スライドバー数値表示を更新中...');
        
        // 各スライダーの値表示を更新
        for (let i = 1; i <= 4; i++) {
            const sizeElement = document.getElementById('size' + i);
            const weightElement = document.getElementById('weight' + i);
            const stWidthElement = document.getElementById('st_width' + i);
            
            const sizeViewElement = document.getElementById('text_size_view' + i);
            const weightViewElement = document.getElementById('text_weight_view' + i);
            const stSizeViewElement = document.getElementById('text_st_size_view' + i);
            
            if (sizeElement && sizeViewElement) {
                sizeViewElement.innerHTML = sizeElement.value;
                console.log('size' + i + '表示を更新:', sizeElement.value);
            }
            if (weightElement && weightViewElement) {
                weightViewElement.innerHTML = weightElement.value;
                console.log('weight' + i + '表示を更新:', weightElement.value);
            }
            if (stWidthElement && stSizeViewElement) {
                stSizeViewElement.innerHTML = stWidthElement.value;
                console.log('st_width' + i + '表示を更新:', stWidthElement.value);
            }
        }
        
        // 行間設定の表示を更新
        for (let i = 1; i <= 3; i++) {
            const lineSpacingElement = document.getElementById('line_spacing_' + i);
            const lineSpacingValueElement = document.getElementById('line_spacing_' + i + '_value');
            
            if (lineSpacingElement && lineSpacingValueElement) {
                lineSpacingValueElement.textContent = lineSpacingElement.value + 'px';
                console.log('line_spacing_' + i + '表示を更新:', lineSpacingElement.value + 'px');
            }
        }
        
        console.log('スライドバー数値表示更新完了');
    }
</script>

<!-- # 音声レベル監視機能　############################ -->
<!-- 音量表示機能は削除されました（音声認識デバイスとの不一致によるユーザー混乱防止のため） -->
<script>
    // 音声レベル監視用の変数（無効化）
    // let audioContext = null;
    // let analyser = null;
    // let microphone = null;
    // let dataArray = null;
    
    // Web Speech APIはデバイス選択をサポートしないため、この機能は無効化
    function refreshAudioDevices() {
        console.log('Web Speech APIの制限により、音声デバイス選択は使用できません');
        console.log('既定の音声入力デバイスのみ使用されます');
        // 音声レベル監視は削除されました（音声認識デバイスとの不一致によるユーザー混乱防止のため）
        // startAudioLevelMonitoring();
    }
    
    // 音声レベル監視を開始（既定デバイスのみ使用）
    async function startAudioLevelMonitoring() {
        // 音声レベル監視は削除されました（音声認識デバイスとの不一致によるユーザー混乱防止のため）
        console.log('音声レベル監視機能は無効化されています');
        /*
        try {
            // Web Speech APIの制限により、常に既定デバイスを使用
            // autoGainControlをfalseに設定して自動ゲイン調整を無効化
            const constraints = { 
                audio: {
                    autoGainControl: false,
                    noiseSuppression: true,
                    echoCancellation: true
                }
            };
                
            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            microphone = audioContext.createMediaStreamSource(stream);
            
            analyser.fftSize = 256;
            const bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);
            
            microphone.connect(analyser);
            
            updateAudioLevel();
            
        } catch (error) {
            console.error('音声レベル監視の開始に失敗:', error);
        }
        */
    }
    
    // 音声レベル監視を停止
    function stopAudioLevelMonitoring() {
        // 音声レベル監視は削除されました（音声認識デバイスとの不一致によるユーザー混乱防止のため）
        console.log('音声レベル監視停止機能は無効化されています');
        /*
        if (microphone) {
            microphone.disconnect();
            microphone = null;
        }
        if (audioContext) {
            audioContext.close();
            audioContext = null;
        }
        document.getElementById('audioLevelCover').style.width = '100%';
        document.getElementById('audioLevelText').textContent = '0%';
        */
    }
    
    // 音声レベルを更新（無効化）
    function updateAudioLevel() {
        // 音声レベル監視は削除されました（音声認識デバイスとの不一致によるユーザー混乱防止のため）
        return;
        /*
        if (!analyser || !dataArray) return;
        
        analyser.getByteFrequencyData(dataArray);
        
        let sum = 0;
        for (let i = 0; i < dataArray.length; i++) {
            sum += dataArray[i];
        }
        const average = sum / dataArray.length;
        const level = Math.min(100, (average / 128) * 100);
        
        // カバーの幅を調整（レベルが高いほどカバーが狭くなる）
        document.getElementById('audioLevelCover').style.width = (100 - level) + '%';
        document.getElementById('audioLevelText').textContent = Math.round(level) + '%';
        
        // 常に更新を続ける
        requestAnimationFrame(updateAudioLevel);
        */
    }
    
    // Web Speech APIの制限により、デバイス選択機能は無効化
    document.addEventListener('DOMContentLoaded', function() {
        // Font Access API対応状況をチェックして表示（無効化）
        // checkFontAPIStatus();
        
        // 音声レベル監視は削除されました（音声認識デバイスとの不一致によるユーザー混乱防止のため）
        // refreshAudioDevices();
        
        // メッセージリスナーを確実に登録
        setupMessageListener();
        
        // システムフォント選択メニューを初期化
        setTimeout(initializeFontSelectors, 100);
        
        // プリセット初期化（保存済み設定復元）
        setTimeout(initializePresets, 200);
        
        // DOM読み込み完了後に設定を確実に反映
        setTimeout(applyInitialSettings, 800);
        
        // さらに確実にするため、追加のタイマーでも実行
        setTimeout(applyInitialSettings, 1500);
    });
</script>

<!-- # 翻訳回数取得　############################ -->
<script>
    function getTranslationCount() {
        var iframe = document.getElementById('asr_frame');
        var transCount = iframe.contentWindow.document.getElementById('translationCount').innerHTML;
        if(transCount == ''){
            transCount = '[ココに回数出るよ！]';
        }
        return transCount;
    }

    // 1秒ごとに翻訳カウントを更新
    setInterval(function() {
        document.getElementById('displayTransCount').innerHTML = getTranslationCount();
    }, 1000);
</script>

<!-- # iframeの高さを切り替える　############################ -->
<script>
    function toggleIframeHeight() {
        console.log("toggleIframeHeight");
        var iframe = document.getElementById('asr_frame');
        var body = document.body;

        // ページのスクロール位置を一番上に戻す
        window.scrollTo(0, 0);

        if (iframe.style.height === '100%') {
            iframe.style.height = '30%';
            body.style.overflow = 'auto';  // ページスクロールを有効にする
        } else {
            iframe.style.height = '100%';
            body.style.overflow = 'hidden';  // ページスクロールを禁止する
        }

        document.getElementById('frame_height').value = iframe.style.height;
        updateOptionValues();
    }
</script>

<!-- iframeの高さを自動調整する -->
<script>
    window.addEventListener('load', function() {
        var iframe = document.getElementById('asr_frame');
        
        // iframeの読み込み完了を待つ
        iframe.addEventListener('load', function() {
            try {
                var iframeDoc = iframe.contentDocument || iframe.contentWindow.document;
                
                iframeDoc.addEventListener('click', function() {
                    toggleIframeHeight();
                });
                
                // iframe読み込み完了後に翻訳方法を確実に送信
                setTimeout(() => {
                    updateTranslationMethodInIframe();
                    console.log('iframe読み込み完了後に翻訳方法を送信');
                    
                    // Chrome翻訳が選択されている場合、タイマー開始を確認
                    const chromeRadio = document.getElementById('translationMethodChrome');
                    if (chromeRadio && chromeRadio.checked) {
                        console.log('Chrome翻訳選択確認 - タイマー開始確認');
                        setTimeout(() => {
                            updateTranslationMethodInIframe('chrome');
                        }, 1000);
                    }
                }, 500);
            } catch (e) {
                console.error('iframeへのアクセスに失敗:', e);
            }
        });
        
        // ページ全体のロード完了後に設定を確実に反映
        setTimeout(applyInitialSettings, 1000);
    });
</script>

<!-- # プリセット初期化（最終実行） ###################### -->
<script>
    // ページ完全読み込み後にプリセット初期化を実行
    window.addEventListener('load', function() {
        console.log('ページ完全読み込み完了 - プリセット初期化実行');
        
        // 少し遅延して確実に実行
        setTimeout(function() {
            console.log('プリセット初期化開始');
            
            const presetSelect = document.getElementById('presetSelect');
            if (!presetSelect) {
                console.error('プリセットセレクトボックスが見つかりません');
                return;
            }
            
            // localStorageから保存されたプリセット選択状態を復元
            const savedSelectedPreset = localStorage.getItem('selectedPreset');
            console.log('保存されたプリセット選択状態:', savedSelectedPreset);
            
            if (savedSelectedPreset) {
                console.log('保存されたプリセットを復元:', savedSelectedPreset);
                presetSelect.value = savedSelectedPreset;
                
                // プルダウンの値が正しく設定されたか確認
                if (presetSelect.value === savedSelectedPreset) {
                    console.log('プルダウン復元成功:', savedSelectedPreset);
                    // プリセットを実際に読み込む
                    const event = new Event('change');
                    presetSelect.dispatchEvent(event);
                } else {
                    console.error('プルダウン復元失敗:', savedSelectedPreset, '現在値:', presetSelect.value);
                }
            } else {
                console.log('保存されたプリセットなし、デフォルト値を使用');
                presetSelect.value = 'default';
                // デフォルトプリセットを読み込む
                const event = new Event('change');
                presetSelect.dispatchEvent(event);
            }
        }, 500);
    });
    
    // iframeからのダウンロード状況メッセージを受信
    window.addEventListener('message', function(event) {
        // セキュリティのため、信頼できるソースからのメッセージのみ処理
        if (event.data && event.data.type === 'modelDownloadRequired') {
            // 音声認識後の翻訳でモデルダウンロードが必要な場合
            console.log('音声認識後の翻訳でモデルダウンロードが必要:', event.data);
            
            // 既にpendingModelsに含まれているか確認
            const exists = pendingModels.some(m => 
                m.sourceLang === event.data.sourceLang && 
                m.targetLang === event.data.targetLang
            );
            
            if (!exists) {
                // pendingModelsに追加
                pendingModels.push({
                    sourceLang: event.data.sourceLang,
                    targetLang: event.data.targetLang,
                    translationNum: event.data.translationNum
                });
                
                // ダウンロードボタンを表示
                const modelArea = document.getElementById('modelDownloadArea');
                const btn = document.getElementById('preloadModelBtn');
                
                if (modelArea && btn) {
                    // 最初のモデル情報を表示
                    const firstModel = pendingModels[0];
                    const sourceDisplayName = getLanguageDisplayName(firstModel.sourceLang);
                    const targetDisplayName = getLanguageDisplayName(firstModel.targetLang);
                    
                    btn.textContent = `📥 ${sourceDisplayName}→${targetDisplayName}のモデルをダウンロード`;
                    btn.disabled = false;
                    btn.style.backgroundColor = '#4CAF50';
                    btn.style.color = 'white';
                    
                    modelArea.style.display = 'block';
                    
                    // ダウンロード状況も表示
                    const statusArea = document.getElementById('downloadStatusArea');
                    const statusText = document.getElementById('downloadStatusText');
                    if (statusArea && statusText) {
                        statusText.innerHTML = `⚠️ 音声認識後の翻訳にモデルが必要です`;
                        statusArea.style.display = 'block';
                        statusArea.style.background = 'linear-gradient(135deg, #fff3cd 0%, #ffe8a1 100%)';
                        
                        // 5秒後に非表示
                        setTimeout(() => {
                            statusArea.style.display = 'none';
                        }, 5000);
                    }
                }
                
                updateQueueStatus();
            }
        } else if (event.data && event.data.type === 'downloadStatus') {
            const statusArea = document.getElementById('downloadStatusArea');
            const statusText = document.getElementById('downloadStatusText');
            
            if (statusArea && statusText) {
                if (event.data.status === 'downloading') {
                    // 進捗率がある場合は表示
                    const progressText = event.data.progress !== undefined 
                        ? `🔄 ${event.data.message}` 
                        : '🔄 ' + event.data.message;
                    statusText.innerHTML = progressText;
                    statusArea.style.display = 'block';
                    
                    // 進捗率に応じて背景色を変化
                    if (event.data.progress !== undefined) {
                        const progress = event.data.progress;
                        // グラデーションで進捗を表現
                        statusArea.style.background = `linear-gradient(90deg, #ffa726 ${progress}%, #ffe0b2 ${progress}%)`;
                    } else {
                        statusArea.style.background = 'linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%)';
                    }
                } else if (event.data.status === 'completed') {
                    statusText.innerHTML = '✅ ' + event.data.message;
                    statusArea.style.display = 'block';
                    statusArea.style.background = 'linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%)';
                    // 3秒後に非表示
                    setTimeout(() => {
                        statusArea.style.display = 'none';
                    }, 3000);
                } else if (event.data.status === 'error') {
                    statusText.innerHTML = '❌ ' + event.data.message;
                    statusArea.style.display = 'block';
                    statusArea.style.background = 'linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%)';
                    // 5秒後に非表示
                    setTimeout(() => {
                        statusArea.style.display = 'none';
                    }, 5000);
                }
            }
        }
    });
    
    // Chrome Translation API 事前ダウンロード機能
    let currentTranslationPair = null; // 現在選択されている言語ペア
    let pendingModels = []; // ダウンロード待ちのモデルリスト
    
    // ダウンロード待ちモデル数の表示を更新
    function updateQueueStatus() {
        const queueStatus = document.getElementById('modelQueueStatus');
        if (queueStatus) {
            if (pendingModels.length > 0) {
                queueStatus.style.display = 'inline-block';
                queueStatus.textContent = `📦 残り${pendingModels.length}個`;
                
                // 個数によって色を変える
                if (pendingModels.length === 1) {
                    queueStatus.style.background = 'rgba(76, 175, 80, 0.1)';
                    queueStatus.style.color = '#4CAF50';
                } else if (pendingModels.length <= 3) {
                    queueStatus.style.background = 'rgba(255, 193, 7, 0.1)';
                    queueStatus.style.color = '#f57c00';
                } else {
                    queueStatus.style.background = 'rgba(244, 67, 54, 0.1)';
                    queueStatus.style.color = '#d32f2f';
                }
            } else {
                queueStatus.style.display = 'none';
            }
        }
    }
    
    // 全ての翻訳モデルをチェック（音声認識言語変更時用）
    function checkAllTranslationModels() {
        // 音声認識言語変更時は待機リストをクリア
        pendingModels = [];
        updateQueueStatus(); // キュー状態をリセット
        
        // ボタンの状態もリセット
        const modelBtn = document.getElementById('preloadModelBtn');
        const modelStatus = document.getElementById('modelStatusText');
        if (modelBtn) {
            modelBtn.disabled = false;
            modelBtn.style.background = '#ff6b6b';
        }
        if (modelStatus) {
            modelStatus.textContent = '';
            modelStatus.style.color = '#333';
        }
        
        // エラーを防ぐため、各チェックをtry-catchで囲む
        try {
            checkTranslationModel(1);
        } catch (error) {
            console.error('翻訳1モデルチェックエラー:', error);
        }
        try {
            checkTranslationModel(2);
        } catch (error) {
            console.error('翻訳2モデルチェックエラー:', error);
        }
        try {
            checkTranslationModel(3);
        } catch (error) {
            console.error('翻訳3モデルチェックエラー:', error);
        }
    }
    
    function checkTranslationModel(transNum = 1, event = null) {
        // Chrome Translation APIが利用可能な場合のみ
        if (!('Translator' in self)) return;
        
        const recogSelect = document.getElementById('recog');
        let transSelectId = 'trans';
        if (transNum === 2) transSelectId = 'trans2';
        if (transNum === 3) transSelectId = 'trans3';
        
        const transSelect = document.getElementById(transSelectId);
        const modelArea = document.getElementById('modelDownloadArea');
        const modelBtn = document.getElementById('preloadModelBtn');
        const modelStatus = document.getElementById('modelStatusText');
        
        if (!transSelect) return;
        
        const sourceLang = recogSelect.value;
        const targetLang = transSelect.value;
        
        // 翻訳言語が選択されていない場合は何もしない
        if (targetLang === 'none') {
            currentTranslationPair = null;
            return;
        }
        
        // 同一言語の場合も何もしない（翻訳はスキップされる）
        if (sourceLang === targetLang) {
            return;
        }
        
        // iframe内のchromeTranslatorを取得
        const iframe = document.getElementById('asr_frame');
        if (!iframe || !iframe.contentWindow || !iframe.contentWindow.chromeTranslator) {
            console.log('Chrome Translator が準備されていません');
            return;
        }
        
        const translator = iframe.contentWindow.chromeTranslator;
        
        // 言語コードを正規化
        const normalizedSource = translator.normalizeLanguageCode(sourceLang);
        const normalizedTarget = translator.normalizeLanguageCode(targetLang);
        
        currentTranslationPair = {
            source: sourceLang,
            target: targetLang,
            normalizedSource: normalizedSource,
            normalizedTarget: normalizedTarget
        };
        
        // 言語名を取得
        const targetLangName = transSelect.options[transSelect.selectedIndex].text;
        
        // 翻訳可能性をチェック（エラーハンドリング強化）
        Translator.availability({
            sourceLanguage: normalizedSource,
            targetLanguage: normalizedTarget
        }).then(availability => {
            console.log(`翻訳${transNum} モデル状態: ${sourceLang} → ${targetLang} = ${availability}`);
            
            if (availability === 'downloadable') {
                // ダウンロード可能な場合
                console.log(`翻訳${transNum}用モデルをダウンロード可能: ${targetLangName}`);
                
                // イベントが渡されていれば（翻訳言語プルダウン変更時）自動ダウンロード
                const isDirectUserGesture = event && (event.type === 'change');
                
                if (isDirectUserGesture) {
                    // 翻訳言語プルダウン変更による直接的なユーザージェスチャー
                    console.log(`翻訳${transNum}用モデルを自動ダウンロード開始（プルダウン変更）: ${targetLangName}`);
                    
                    // pendingModelsから該当するモデルを削除
                    pendingModels = pendingModels.filter(m => 
                        !(m.sourceLang === normalizedSource && 
                          m.targetLang === normalizedTarget)
                    );
                    updateQueueStatus();
                    
                    translator.preloadLanguagePack(normalizedSource, normalizedTarget).then(() => {
                        console.log(`翻訳${transNum}用モデルのダウンロード完了: ${targetLangName}`);
                        
                        // pendingModelsに残りがあるか確認
                        if (pendingModels.length > 0) {
                            // 残りがある場合は次のモデルのボタンを表示
                            const nextModel = pendingModels[0];
                            if (modelArea && modelBtn) {
                                modelArea.style.display = 'block';
                                modelBtn.style.display = 'inline-block';
                                modelBtn.disabled = false;
                                modelBtn.style.background = '#ff6b6b';
                                modelBtn.innerHTML = `📥 ${nextModel.langName}モデルをダウンロード`;
                                modelStatus.textContent = `✅ ${targetLangName}完了！`;
                                modelStatus.style.color = '#4CAF50';
                                
                                // currentTranslationPairを更新
                                currentTranslationPair = {
                                    source: nextModel.sourceLang,
                                    target: nextModel.targetLang,
                                    normalizedSource: nextModel.sourceLang,
                                    normalizedTarget: nextModel.targetLang
                                };
                            }
                        } else {
                            // 全て完了した場合のみボタンエリアを非表示に
                            if (transNum === 1 && modelArea) {
                                modelArea.style.display = 'none';
                            }
                        }
                    }).catch(error => {
                        console.error(`翻訳${transNum}用モデルのダウンロードエラー:`, error);
                        
                        // エラー時は翻訳1の場合のみボタンを表示
                        if (transNum === 1 && modelArea) {
                            modelArea.style.display = 'block';
                            modelBtn.style.display = 'inline-block';
                            modelBtn.disabled = false;
                            modelBtn.style.background = '#ff6b6b';
                            modelBtn.innerHTML = `📥 ${targetLangName}モデルをダウンロード`;
                            modelStatus.textContent = 'エラー: 手動でダウンロードしてください';
                            modelStatus.style.color = '#f44336';
                        }
                    });
                } else {
                    // 音声認識言語変更による間接的な呼び出し
                    console.log(`翻訳${transNum}用モデルは手動ダウンロードが必要（音声認識言語変更）: ${targetLangName}`);
                    
                    // 重複を避けてダウンロード待ちリストに追加
                    const exists = pendingModels.some(m => 
                        m.sourceLang === normalizedSource && 
                        m.targetLang === normalizedTarget
                    );
                    
                    if (!exists) {
                        pendingModels.push({
                            transNum: transNum,
                            sourceLang: normalizedSource,
                            targetLang: normalizedTarget,
                            langName: targetLangName
                        });
                        updateQueueStatus(); // キュー状態を更新
                    }
                    
                    // pendingModelsに何かある場合は最初のモデルのボタンを表示
                    if (pendingModels.length > 0 && modelArea && modelBtn) {
                        const firstModel = pendingModels[0];
                        modelArea.style.display = 'block';
                        modelBtn.style.display = 'inline-block';
                        modelBtn.disabled = false; // ボタンを有効化
                        modelBtn.style.background = '#ff6b6b'; // 背景色をリセット（赤）
                        modelBtn.innerHTML = `📥 ${firstModel.langName}モデルをダウンロード`;
                        modelStatus.textContent = '音声認識言語変更後は手動ダウンロードが必要です';
                        modelStatus.style.color = '#333'; // テキスト色もリセット
                        
                        // ボタンのクリックで最初のモデルをダウンロード
                        currentTranslationPair = {
                            source: sourceLang,
                            target: targetLang,
                            normalizedSource: normalizedSource,
                            normalizedTarget: normalizedTarget
                        };
                    } else if (pendingModels.length > 1 && transNum === 1 && modelArea) {
                        // 複数のモデルが待機中の場合は案内を表示
                        modelStatus.textContent = `他に${pendingModels.length - 1}個のモデルがダウンロード待機中`;
                    }
                }
            } else if (availability === 'available') {
                // 既にダウンロード済み
                console.log(`翻訳${transNum}用モデルは既にダウンロード済み: ${targetLangName}`);
                // すべてのモデルがダウンロード済みでpendingModelsが空の場合のみボタンエリアを非表示
                if (pendingModels.length === 0 && modelArea) {
                    modelArea.style.display = 'none';
                }
            } else {
                // 利用不可
                console.log(`翻訳${transNum}用モデルは利用不可: ${targetLangName} (${availability})`);
                // すべてのモデルが利用不可でpendingModelsが空の場合のみボタンエリアを非表示
                if (pendingModels.length === 0 && modelArea) {
                    modelArea.style.display = 'none';
                }
            }
        }).catch(error => {
            console.error('翻訳可能性チェックエラー:', error);
        });
    }
    
    function preloadTranslationModel() {
        // pendingModelsから最初のモデルを取得するか、currentTranslationPairを使用
        let modelToDownload = null;
        
        if (pendingModels.length > 0) {
            modelToDownload = pendingModels[0];
        } else if (currentTranslationPair) {
            modelToDownload = {
                sourceLang: currentTranslationPair.normalizedSource,
                targetLang: currentTranslationPair.normalizedTarget,
                langName: currentTranslationPair.targetLangName || '翻訳言語'
            };
        }
        
        if (!modelToDownload) return;
        
        const modelBtn = document.getElementById('preloadModelBtn');
        const modelStatus = document.getElementById('modelStatusText');
        
        // iframe内のchromeTranslatorを取得
        const iframe = document.getElementById('asr_frame');
        if (!iframe || !iframe.contentWindow || !iframe.contentWindow.chromeTranslator) {
            alert('Chrome Translator が準備されていません。ページをリロードしてください。');
            return;
        }
        
        const translator = iframe.contentWindow.chromeTranslator;
        
        // モデル情報から言語名を取得
        const targetLangName = modelToDownload.langName;
        
        // ボタンを無効化
        modelBtn.disabled = true;
        modelBtn.innerHTML = `📥 ${targetLangName}をダウンロード準備中...`;
        modelStatus.textContent = '';
        
        // ダウンロード進捗を監視
        translator.onDownloadStatusChange = (status) => {
            if (status.status === 'downloading' && status.progress !== undefined) {
                modelBtn.innerHTML = `⏳ ${targetLangName}をダウンロード中... ${status.progress}%`;
                // プログレスバー表示（ボタンの背景として）
                modelBtn.style.background = `linear-gradient(90deg, #4CAF50 ${status.progress}%, #ff6b6b ${status.progress}%)`;
            }
        };
        
        // 事前ダウンロードを実行
        translator.preloadLanguagePack(modelToDownload.sourceLang, modelToDownload.targetLang).then(result => {
            if (result) {
                // 完了したモデルをリストから削除
                if (pendingModels.length > 0) {
                    pendingModels = pendingModels.filter(m => 
                        !(m.sourceLang === modelToDownload.sourceLang && 
                          m.targetLang === modelToDownload.targetLang)
                    );
                    updateQueueStatus(); // キュー状態を更新
                }
                
                // 次のモデルがある場合
                if (pendingModels.length > 0) {
                    const nextModel = pendingModels[0];
                    modelBtn.disabled = false;
                    modelBtn.style.background = '#ff6b6b';
                    modelBtn.innerHTML = `📥 ${nextModel.langName}モデルをダウンロード`;
                    modelStatus.textContent = `✅ ${targetLangName}完了！`;
                    modelStatus.style.color = '#4CAF50';
                    
                    // 次のモデル用にcurrentTranslationPairを更新
                    currentTranslationPair = {
                        normalizedSource: nextModel.sourceLang,
                        normalizedTarget: nextModel.targetLang,
                        targetLangName: nextModel.langName
                    };
                } else {
                    // 全て完了
                    modelBtn.style.display = 'none';
                    modelStatus.textContent = '✅ 全モデルのダウンロード完了！';
                    modelStatus.style.color = '#4CAF50';
                    setTimeout(() => {
                        const modelArea = document.getElementById('modelDownloadArea');
                        if (modelArea) modelArea.style.display = 'none';
                    }, 3000);
                    currentTranslationPair = null;
                }
            } else {
                modelBtn.disabled = false;
                modelBtn.style.background = '#ff6b6b';
                modelBtn.innerHTML = `📥 ${targetLangName}モデルをダウンロード`;
                modelStatus.textContent = '❌ ダウンロード失敗';
                modelStatus.style.color = '#f44336';
            }
        }).catch(error => {
            console.error('事前ダウンロードエラー:', error);
            modelBtn.disabled = false;
            modelBtn.style.background = '#ff6b6b';
            modelBtn.innerHTML = `📥 ${targetLangName}モデルをダウンロード`;
            modelStatus.textContent = '❌ エラー: ' + error.message;
            modelStatus.style.color = '#f44336';
        });
    }
    
    // ページ読み込み時に初期チェック
    setTimeout(() => {
        checkTranslationModel();
    }, 2000);
</script>

</html>